---
title: "MVE Blue Seeds"
author: "Brooke Wainwright"
format: html
editor: visual
---

## Background

The Sevilleta Long Term Ecological Research (LTER) Program (Socorro, NM) rolled out a novel climate change experiment in 2019: the Mean-Variance Experiment (MVE). The experiment has been replicated in four ecosystems to date but the focus of this document is on the experimental infrastructure found in the Great Plains Grassland ecosystem, dominated by blue grama grass (*Bouteloua gracilis*). Hence Mean-Variance Blue or MVE Blue. The ecosystem is dominated by blue grama grass but the adjacent ecosystem, Chihuahuan Desert Grassland, is dominated by black grama grass (*Bouteloua eriopoda*). Great Plains Grassland extends northward throughout central North America while Chihuahuan Desert Grassland extends southward into Mexico. Thus, under a more arid climate, we would expect Chihuahuan Desert Grassland to expand it's range northward. The experimental infrastructure is set near the ecotone of these two ecosystems. More information on this experiment can be found here: <https://sevlter.unm.edu/mean-variance-experiment/>. To test the recruitment dynamics of these dominant plants under climate change, we added seeds of each species to the experimental plots from 2019-2023 and tracked their germination and survival biweekly during the growing season and monthly during the dormant season.

## Objectives

1.  Read in relevant data (seed monitoring data for all five years, treatments, soil moisture data, climate data).
2.  Create new and necessary dataframes.
3.  Create graph of typical climate for temperature and precipitation.
4.  Find the best model for the germination data using year and mean and variance treatments as predictors
5.  Graph germination by year, mean, and variance by species.
6.  Figure out the 1-3 events each year where 90-95% of germination occurs and isolate germination and soil moisture to those events and build a model to understand how soil moisture determines germination probability. Graph.
7.  Find best model of survival by species, year, and mean and variance treatments. Or a model for each species. Graph.
8.  Test for legacy effects on germination by using precipitation whiplash or biomass. Graph.

## Setup

Read in necessary packages.

```{r}
#| message: false
#| warning: false

library(readr)
library(dplyr)
library(tidyr)
library(tidyverse)
library(ggplot2)
library(viridis) # colorblind friendly color palette
library(reshape2)
library(vegan)
library(lme4)
library(car)
library(readxl)
library(googlesheets4)
library(lubridate)
library(bbmle)
library(lmtest)
library(beepr)
library(survival)
library(ggsurvfit)
library(survminer)
library(emmeans)
```

## Clean and Wrangle Data

Bring in seed monitoring data for all five years, keys, soil moisture data, and climate data.

### Seed monitoring

```{r seed census data hidden}
#| eval: false # Do not evaluate this chunk
#| echo: false # Do not show chunk on html
# This reduces computing power -- a lot of carpentry happens here. This way we don't have to do it every time we run the code

# bring in each year of data (2019-2023, 5 years total)

# De-authorize googlesheets to bypass log-in
googlesheets4::gs4_deauth()

# Load in the data from google drive (make loop or function)
blue_2019 <- as.data.frame(googlesheets4::read_sheet(
  ss="https://docs.google.com/spreadsheets/d/1BDSYfiaHBwYWqZEIeu27-rVX_AMyd407eGlDyf7hc6g/edit?gid=1889905658#gid=1889905658"))

blue_2020 <- as.data.frame(googlesheets4::read_sheet(
  ss="https://docs.google.com/spreadsheets/d/1RfcWQR4zSo-6zbAwZbR5s9DhxPF_gderfNvnlOFTxLE/edit#gid=974160277"))

blue_2021 <- as.data.frame(googlesheets4::read_sheet(
  ss="https://docs.google.com/spreadsheets/d/1Y6MBlHEawdBZKeywWfAKHqT4wDQxGLlTCyE1NG0Mfe8/edit#gid=1947016736"))

blue_2022 <- as.data.frame(googlesheets4::read_sheet(
  ss="https://docs.google.com/spreadsheets/d/1bixaeVyjCgqI7d3j5kNcQwR9zRAd9duY9ipoA2uWvaY/edit#gid=1207134008"))

blue_2023 <- as.data.frame(googlesheets4::read_sheet(
  ss="https://docs.google.com/spreadsheets/d/1712pb0TIKS5K3FU3-pRHc9oI3K6uavZMcF8a3YW8SHY/edit#gid=0"))

# Change column header dates to be readable by R (make loop or fxn)
names(blue_2019)[str_detect(names(blue_2019), "\\d{5}")] <- 
  format(as.Date(as.numeric(names(blue_2019)[str_detect(names(blue_2019), "\\d{5}")]), origin = "1899-12-30"), "%d-%b-%y")

names(blue_2020)[str_detect(names(blue_2020), "\\d{5}")] <- 
  format(as.Date(as.numeric(names(blue_2020)[str_detect(names(blue_2020), "\\d{5}")]), origin = "1899-12-30"), "%d-%b-%y")

names(blue_2021)[str_detect(names(blue_2021), "\\d{5}")] <- 
  format(as.Date(as.numeric(names(blue_2021)[str_detect(names(blue_2021), "\\d{5}")]), origin = "1899-12-30"), "%d-%b-%y")

names(blue_2022)[str_detect(names(blue_2022), "\\d{5}")] <- 
  format(as.Date(as.numeric(names(blue_2022)[str_detect(names(blue_2022), "\\d{5}")]), origin = "1899-12-30"), "%d-%b-%y")

names(blue_2023)[str_detect(names(blue_2023), "\\d{5}")] <- 
  format(as.Date(as.numeric(names(blue_2023)[str_detect(names(blue_2023), "\\d{5}")]), origin = "1899-12-30"), "%d-%b-%y")

# Give the cohort name for each dataframe (make loop or fxn)
blue_2019$Add_Year <- 2019
blue_2020$Add_Year <- 2020
blue_2021$Add_Year <- 2021
blue_2022$Add_Year <- 2022
blue_2023$Add_Year <- 2023

# convert columns to numeric (make loop or fxn)
blue_2019 <- blue_2019 %>%
  mutate(across( # mutate observations in multiple columns
    matches("\\d{1,2}-"), # that contain digits in the column name
    as.numeric)) 
blue_2020 <- blue_2020 %>%
  mutate(across( # mutate observations in multiple columns
    matches("\\d{1,2}-"), # that contain digits in the column name
    as.numeric)) 
blue_2021 <- blue_2021 %>%
  mutate(across( # mutate observations in multiple columns
    matches("\\d{1,2}-"), # that contain digits in the column name
    as.numeric)) 
blue_2022 <- blue_2022 %>%
  mutate(across( # mutate observations in multiple columns
    matches("\\d{1,2}-"), # that contain digits in the column name
    as.numeric)) 
blue_2023 <- blue_2023 %>%
  mutate(across( # mutate observations in multiple columns
    matches("\\d{1,2}-"), # that contain digits in the column name
    as.numeric)) 

# make TP ID (make loop or fxn)
blue_2019$TP_ID<- 
  with(blue_2019, 
       paste0(Add_Year, Plot, Species, Corner, Row, Column))
blue_2020$TP_ID<- 
  with(blue_2020, 
       paste0(Add_Year, Plot, Species, Corner, Row, Column))
blue_2021$TP_ID<- 
  with(blue_2021, 
       paste0(Add_Year, Plot, Species, Corner, Row, Column))
blue_2022$TP_ID<- 
  with(blue_2022, 
       paste0(Add_Year, Plot, Species, Corner, Row, Column))
blue_2023$TP_ID<- 
  with(blue_2023, 
       paste0(Add_Year, Plot, Species, Corner, Row, Column))

# pivot long (make loop or fxn)
blue_2019_long <-
  pivot_longer(blue_2019,
               cols = c("2019-09-07":"2019-10-13"),
               names_to = "Obs_Date",
               values_to = "Germ.binom") %>%
  mutate(Obs_Date=as.Date(Obs_Date,format="%Y-%m-%d")) # Format dates
unique(blue_2019_long$Obs_Date)

blue_2020_long <-
  pivot_longer(blue_2020,
               cols = c("7/31/2020":"6/2/2023"),
               names_to = "Obs_Date",
               values_to = "Germ.binom") %>%
  mutate(Obs_Date=as.Date(Obs_Date,format="%m/%d/%Y")) # Format dates
unique(blue_2020_long$Obs_Date)

blue_2021_long <-
  pivot_longer(blue_2021,
               cols = c("2021-07-26":"2024-05-06"),
               names_to = "Obs_Date",
               values_to = "Germ.binom") %>%
  mutate(Obs_Date=as.Date(Obs_Date,format="%Y-%m-%d")) # Format dates
unique(blue_2021_long$Obs_Date)

blue_2022_long <-
  pivot_longer(blue_2022,
               cols = c("2022-07-05":"2024-04-03"),
               names_to = "Obs_Date",
               values_to = "Germ.binom") %>%
  mutate(Obs_Date=as.Date(Obs_Date,format="%Y-%m-%d")) 
# Format dates
unique(blue_2022_long$Obs_Date)

blue_2023_long <-
  pivot_longer(blue_2023,
               cols = c("2023-07-07":"2024-08-05"),
               names_to = "Obs_Date",
               values_to = "Germ.binom") %>%
  mutate(Obs_Date=as.Date(Obs_Date,format="%Y-%m-%d")) 
# Format dates
unique(blue_2023_long$Obs_Date)

# reduce germ to 1 (make loop or function)
blue_2019_long <-
  blue_2019_long %>%
  mutate(
    Germ.binom =
      case_when(
        Germ.binom == 1 ~ 1
        , Germ.binom == 2 ~ 1
        , Germ.binom == 3 ~ 1
        , Germ.binom == 0 ~ 0
      )
  )
blue_2020_long <-
  blue_2020_long %>%
  mutate(
    Germ.binom =
      case_when(
        Germ.binom == 1 ~ 1
        , Germ.binom == 2 ~ 1
        , Germ.binom == 3 ~ 1
        , Germ.binom == 0 ~ 0
      )
  )
blue_2021_long <-
  blue_2021_long %>%
  mutate(
    Germ.binom =
      case_when(
        Germ.binom == 1 ~ 1
        , Germ.binom == 2 ~ 1
        , Germ.binom == 3 ~ 1
        , Germ.binom == 0 ~ 0
      )
  )
blue_2022_long <-
  blue_2022_long %>%
  mutate(
    Germ.binom =
      case_when(
        Germ.binom == 1 ~ 1
        , Germ.binom == 2 ~ 1
        , Germ.binom == 3 ~ 1
        , Germ.binom == 0 ~ 0
      )
  )
blue_2023_long <-
  blue_2023_long %>%
  mutate(
    Germ.binom =
      case_when(
        Germ.binom == 1 ~ 1
        , Germ.binom == 2 ~ 1
        , Germ.binom == 3 ~ 1
        , Germ.binom == 0 ~ 0
      )
  )

# order by germ binom then by obs date in order to rm duplicates (make loop or function)
blue_2019_long_reduced <- blue_2019_long[order(-blue_2019_long$Germ.binom, blue_2019_long$Obs_Date), ]
blue_2020_long_reduced <- blue_2020_long[order(-blue_2020_long$Germ.binom, blue_2020_long$Obs_Date), ]
blue_2021_long_reduced <- blue_2021_long[order(-blue_2021_long$Germ.binom, blue_2021_long$Obs_Date), ]
blue_2022_long_reduced <- blue_2022_long[order(-blue_2022_long$Germ.binom, blue_2022_long$Obs_Date), ]
blue_2023_long_reduced <- blue_2023_long[order(-blue_2023_long$Germ.binom, blue_2023_long$Obs_Date), ]

# remove duplicates (make loop or function)
blue_2019_long_reduced <- blue_2019_long_reduced %>%
  distinct(TP_ID, Plot, Corner, Species, Row, Column, Add_Year, .keep_all = TRUE)
blue_2020_long_reduced <- blue_2020_long_reduced %>%
  distinct(TP_ID, Plot, Corner, Species, Row, Column, Add_Year, .keep_all = TRUE)
blue_2021_long_reduced <- blue_2021_long_reduced %>%
  distinct(TP_ID, Plot, Corner, Species, Row, Column, Add_Year, .keep_all = TRUE)
blue_2022_long_reduced <- blue_2022_long_reduced %>%
  distinct(TP_ID, Plot, Corner, Species, Row, Column, Add_Year, .keep_all = TRUE)
blue_2023_long_reduced <- blue_2023_long_reduced %>%
  distinct(TP_ID, Plot, Corner, Species, Row, Column, Add_Year, .keep_all = TRUE)

# Get each year ready fro rbind (make loop or fxn)

blue_2019_long_reduced <-
  blue_2019_long_reduced %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2020_long_reduced <-
  blue_2020_long_reduced %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2021_long_reduced <-
  blue_2021_long_reduced %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2022_long_reduced <-
  blue_2022_long_reduced %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2023_long_reduced <-
  blue_2023_long_reduced %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )

blue_19_23_reduced <- rbind(
  blue_2019_long_reduced,
  blue_2020_long_reduced,
  blue_2021_long_reduced,
  blue_2022_long_reduced,
  blue_2023_long_reduced
  )
summary(blue_19_23_reduced)

write_csv(blue_19_23_reduced, "germ_19_23.csv")
```

```{r alternate long form germ}
#| eval: false # Do not evaluate this chunk
#| echo: false

# Get each year ready for rbind (make loop or fxn)

blue_2019_long <-
  blue_2019_long %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2020_long <-
  blue_2020_long %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2021_long <-
  blue_2021_long %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2022_long <-
  blue_2022_long %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )
blue_2023_long <-
  blue_2023_long %>%
  select(
    Plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Germ.binom
  )

blue_19_23_long_raw <- rbind(
  blue_2019_long,
  blue_2020_long,
  blue_2021_long,
  blue_2022_long,
  blue_2023_long
  )

write_csv(blue_19_23_long_raw, "germ_19_23_long_raw.csv")
# use this for soil moisture
```

So far we have **"germ_19_23.csv"**, which is all the toothpicks and only whether they germinated or not, and **"germ_19_23_long_raw.csv"**, which is the data in long form with toothpicks tracked over time.

Now, make a data frame that looks at the current year and past year cohorts (only) for each monsoon season. But first confirm that most germination happens in first two years.

```{r}
#| warning: false
#| echo: false
# first look at germination over time for each year added cohort -- I expect that we can reduce each one the year planted and the year after, so as to not inflate zeros

# use already cleaned and wrangled data -- this is only whether or not a toothpick germinated, not tracked over time
blue_19_23 <- read_csv("germ_19_23.csv")


blue_19 <- blue_19_23 %>% 
  filter(Add_Year == 2019 & Germ.binom == 1) %>% # Isolate by year and successes
  mutate(Germ_Year = year(Obs_Date)-2018) # Scale by the year planted. So if planted and germinated in 2019, that's year one. If planted in 2019 and germinated in 2020 that's year 2
# hist(blue_19$Germ_Year)

blue_20 <- blue_19_23 %>% 
  filter(Add_Year == 2020 & Germ.binom == 1) %>% 
  mutate(Germ_Year = year(Obs_Date) - 2019)
# hist(blue_20$Germ_Year)

blue_21 <- blue_19_23 %>% 
  filter(Add_Year == 2021 & Germ.binom == 1) %>% 
  mutate(Germ_Year = year(Obs_Date) - 2020)
# hist(blue_21$Germ_Year)

blue_22 <- blue_19_23 %>% 
  filter(Add_Year == 2022 & Germ.binom == 1) %>% 
  mutate(Germ_Year = year(Obs_Date) - 2021)
# hist(blue_22$Germ_Year)

blue_23 <- blue_19_23 %>% 
  filter(Add_Year == 2023 & Germ.binom == 1) %>% 
  mutate(Germ_Year = year(Obs_Date) - 2022)
# hist(blue_23$Germ_Year)

blue_years <- rbind(blue_19, blue_20, blue_21, blue_22, blue_23)

# Germination for all years combined, scaled by year planted
hist(blue_years$Germ_Year)
# this shows that germination declines precipitously after year 1

# get some percentages
total <- sum(blue_years$Germ.binom)
year_sum <- blue_years %>% 
  group_by(Germ_Year) %>% 
  summarise(percent = (sum(Germ.binom)/total)*100)
year_sum
```

75% of germinated seeds occur in their first year, 19% occur in second year, 4% in the third and 0.77% in 4th year.

Sufficient evidence to reduce to first year and second year. Use the long data that tracks each toothpick over time. This results in the dataset **"blue_year_cohorts.csv"** -- not long form, only whether a toothpick germinated in Y1. and if not in Y1 then whether it germed in Y2.

```{r reduce to y1 and y2}
#| warning: false
#| eval: false
#| echo: false

# Make a dataframe for each years crop of available seeds to germ
blue_19_23_long_raw <- read_csv("germ_19_23_long_raw.csv")
summary(blue_19_23_long_raw)

# reduce to observations in the first and second year
blue_2yrs <- blue_19_23_long_raw %>% 
  filter(year(Obs_Date) < Add_Year+2)

# check your work
which(blue_2yrs$Add_Year == 2020 & year(blue_2yrs$Obs_Date) > 2022)
# should be integer(0)

blue_2yrs$Obs_Year <- year(blue_2yrs$Obs_Date)

blue_2yrs <- blue_2yrs %>% 
  mutate(Year = case_when(Obs_Year == Add_Year ~ 1,
                          Obs_Year == Add_Year+1 ~ 2))

# Reduce to germination or zero germination per year
# If it germinates in Year = 1 it should be removed from Year = 2

blue_Y1 <- blue_2yrs %>% 
  filter(Year == 1)

blue_Y1 <- blue_Y1[order(-blue_Y1$Germ.binom, blue_Y1$Obs_Date), ]

# remove duplicates (make loop or function)
blue_Y1 <- blue_Y1 %>%
  distinct(TP_ID, Plot, Corner, Species, Row, Column, Add_Year, .keep_all = TRUE)

blue_Y2 <- blue_2yrs %>% 
  filter(Year == 2)

blue_Y2 <- blue_Y1[order(-blue_Y2$Germ.binom, blue_Y2$Obs_Date), ]

# remove duplicates (make loop or function)
blue_Y2 <- blue_Y2 %>%
  distinct(TP_ID, Plot, Corner, Species, Row, Column, Add_Year, .keep_all = TRUE)

# Remove TP_IDs that germinated in Y1 from Y2
head(blue_Y1)
germs <- blue_Y1$TP_ID[which(blue_Y1$Germ.binom == 1)]

blue_Y2_filt <- blue_Y2 %>%
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germs))) %>%
  ungroup()

which(blue_Y2_filt$TP_ID == "202116BLUENE1G")

blue_y1_y2 <- rbind(blue_Y1, blue_Y2_filt)
blue_y1_y2 <- blue_y1_y2 %>% 
  mutate(plot = Plot)

write_csv(blue_y1_y2, "blue_year_cohorts.csv")
```

Create a dataset limited to the major soil moisture germination events. Isolate data to the two (or three) events per year with the most germination. Then pair with soil moisture data from plots.

```{r}
#| warning: false
#| eval: false
#| echo: false

blue_yr_trt <- read_csv("blue_yr_trt.csv")
str(blue_yr_trt)
head(blue_yr_trt)

# Isolate by year and germinated toothpicks
blue_yr_trt_19_1 <- blue_yr_trt %>% 
  filter(Germ.binom == 1 & Obs_Year == 2019)
blue_yr_trt_20_1 <- blue_yr_trt %>% 
  filter(Germ.binom == 1 & Obs_Year == 2020)
blue_yr_trt_21_1 <- blue_yr_trt %>% 
  filter(Germ.binom == 1 & Obs_Year == 2021)
blue_yr_trt_22_1 <- blue_yr_trt %>% 
  filter(Germ.binom == 1 & Obs_Year == 2022)
blue_yr_trt_23_1 <- blue_yr_trt %>% 
  filter(Germ.binom == 1 & Obs_Year == 2023)

# This shows the high germination events for each observation year
hist(blue_yr_trt_19_1$Obs_Date, "days")
hist(blue_yr_trt_20_1$Obs_Date, "days")
hist(blue_yr_trt_21_1$Obs_Date, "days")
hist(blue_yr_trt_22_1$Obs_Date, "days")
hist(blue_yr_trt_23_1$Obs_Date, "days")
```

```{r}
#| warning: false
#| eval: false
#| echo: false

# Create list of events
# Total germinations per observation day
germ_sm_sum <- blue_yr_trt %>% 
  group_by(Obs_Date,Obs_Year) %>% 
  summarise(sum = sum(Germ.binom))

# Total germinations per year
germ_sm_sum_yr <- blue_yr_trt %>% 
  group_by(Obs_Year) %>% 
  summarise(sumtotal = sum(Germ.binom))

# How much does a single observation day germination count contribute to yearly total?
germ_sum_per <- left_join(germ_sm_sum, germ_sm_sum_yr, by = join_by(Obs_Year))
germ_sum_per$percent_yr <- germ_sum_per$sum/germ_sum_per$sumtotal

# We could use different thresholds for inclusion
# Option 1: The single biggest germ event (highest percent per year)
# Option 2: The n biggest events that add up to 95% of germination occurrence 
# Option 3: All events with over 5% of germs

# Option 3
germ_percent_events <- germ_sum_per %>% 
  filter(percent_yr > 0.05)
nrow(germ_percent_events)
# we get 8 events over 5 years

# Assign event numbers to each
germ_percent_events$event_num <- c(1:nrow(germ_percent_events))

# create key of event date and number
events <- germ_percent_events[,c("Obs_Date","event_num")]

# Remove success germination TPs from following event

# Use the long form, original raw data. limited to year planted and year after
blue_19_23_long_raw <- read_csv("germ_19_23_long_raw.csv")
blue_2yrs <- blue_19_23_long_raw %>% 
  filter(year(Obs_Date) < Add_Year+2)

# These are the key germination events
events$Obs_Date

# I need each Obs Date to include toothpicks that germinated for the first time on that day, and all other toothpicks that didn't germinate on that day and never have up to that point

# remove TP_IDs that germinated before event 1
germ1 <- blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[1])]

# include all remaining toothpicks present for event 1
event1 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[1]) 
event1 <- event1 %>% 
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ1))) %>%
  ungroup()
  
# remove TP IDs that germinated before event 2
germ2 <- blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[2])]
# check your work
length(unique(germ2))
10505-length(unique(germ2))
# include all remaining toothpicks present for event 2
event2 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[2]) 
event2 <- event2 %>%   
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ2))) %>%
  ungroup()

# remove TP IDs that germinated before event 3
germ3 <- unique(blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[3] & blue_2yrs$Obs_Year == 2021)])
length(germ3)

# include all remaining toothpicks present for event 3
event3 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[3]) 
9776-length(germ3) # check your work
event3 <- event3 %>%   
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ3))) %>%
  ungroup()

# remove TP IDs that germinated before event 4
germ4 <- unique(blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[4] & blue_2yrs$Obs_Year == 2021)])
length(germ4)

# include all remaining toothpicks present for event 4
event4 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[4]) 
9776-length(germ4) # check your work
event4 <- event4 %>%   
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ4))) %>%
  ungroup()

# remove TP IDs that germinated before event 5
germ5 <- unique(blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[5] & blue_2yrs$Obs_Year == 2022)])
length(germ5)

# include all remaining toothpicks present for event 4
event5 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[5]) 
nrow(event5)-length(germ5) # check your work
event5 <- event5 %>%   
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ5))) %>%
  ungroup()

# remove TP IDs that germinated before event 6
germ6 <- unique(blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[6] & blue_2yrs$Obs_Year == 2022)])
length(germ6)

# include all remaining toothpicks present for event 6
event6 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[6]) 
nrow(event6)-length(germ6) # check your work
event6 <- event6 %>%   
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ6))) %>%
  ungroup()

# remove TP IDs that germinated before event 7
germ7 <- unique(blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[7] & blue_2yrs$Obs_Year == 2023)])
length(germ7)

# include all remaining toothpicks present for event 7
event7 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[7]) 
nrow(event7)-length(germ7) # check your work
event7 <- event7 %>%   
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ7))) %>%
  ungroup()

# remove TP IDs that germinated before event 8
germ8 <- unique(blue_2yrs$TP_ID[which(blue_2yrs$Germ.binom == 1 & blue_2yrs$Obs_Date < events$Obs_Date[8] & blue_2yrs$Obs_Year == 2023)])
length(germ8)

# include all remaining toothpicks present for event 7
event8 <- blue_2yrs %>% 
  filter(Obs_Date == events$Obs_Date[8]) 
nrow(event8)-length(germ8) # check your work
event8 <- event8 %>%   
  group_by(TP_ID) %>%
  filter(!any(TP_ID %in% c(germ8))) %>%
  ungroup()


sm_germ_events <- rbind(event1,
      event2,
      event3,
      event4,
      event5,
      event6,
      event7,
      event8)

write_csv(sm_germ_events, "germ_events_sm.csv")
```

There's one date for each year with the most germination event and then 4/5 years have a smaller secondary event. 2021 has several aftershock events.

```{r}
#| echo: false
#| message: false

# Create list of events
# Total germinations per observation day
blue_yr_trt <- read_csv("blue_yr_trt.csv")

germ_sm_sum <- blue_yr_trt %>% 
  group_by(Obs_Date,Obs_Year) %>% 
  summarise(sum = sum(Germ.binom))

# Total germinations per year
germ_sm_sum_yr <- blue_yr_trt %>% 
  group_by(Obs_Year) %>% 
  summarise(sumtotal = sum(Germ.binom))

# How much does a single observation day germination count contribute to yearly total?
germ_sum_per <- left_join(germ_sm_sum, germ_sm_sum_yr, by = join_by(Obs_Year))
germ_sum_per$percent_yr <- germ_sum_per$sum/germ_sum_per$sumtotal

germ_percent_events <- germ_sum_per %>% 
  filter(percent_yr > 0.05)
nrow(germ_percent_events)
# we get 8 events over 5 years

# Assign event numbers to each
germ_percent_events$event_num <- c(1:nrow(germ_percent_events))


germ_percent_events
```

Determined events that contributed to over 5% of total germination for that year. Resulted in 8 events across all 5 years. Used the long raw data, limited to year 1 and 2. Removed all toothicks that germinated before event 1 so as not to inflate numerator or denominator. Then did that subsequently for all 8 events. Results in the file **"germ_events_sm.csv"**

Then, code from Kris Hall was used to process soil moisture data, resulting in 6 files (e.g.,**"MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2018.csv"**), one for every year from 2018-2023.

```{r soil moisture hidden}
#| eval: false # Do not evaluate this chunk
#| echo: false

# path to where the load_MVE_data_into_R.R file is located - CHANGE THIS TO THE PATH ON YOUR COMPUTER
source("load_MVE_data_into_R.R")

process_mve <- function(site, year_to_process) {
  # process_mve function:
  # 
  # Takes raw .dat MVE files as input and produces a long version of the data the data
  # as output.
  #
  # Function arguments: 
  # site: "blue", "black", "creosote", "pj", "jsav" are the choices for site, entered into
  #        the function with quotes
  # year: 4-digit year (YYYY) entered into the function without quotes
  
  
  
  # subsets data to be >= to year requested here
  filter_to_year <- year_to_process
  
  
  # folder where final data will be written - CHANGE THIS TO THE PATH ON YOUR COMPUTER WHERE YOU 
  # WANT TO WRITE OUT THE PROCESSED FILES
  folder_out <- "MVE-seeds"
  

  # name of final output file for year of data being processed
  sub_file_name <- if (site == 'blue') {
    paste0("MVE_PlainsGrassland_SoilMoistureTemperature_", filter_to_year, ".csv")
  } else if (site == "black") {
    paste0("MVE_DesertGrassland_SoilMoistureTemperature_", filter_to_year, ".csv")
  } else if (site == "creosote") {
    paste0("MVE_Creosote_SoilMoistureTemperature_", filter_to_year, ".csv")
  } else if (site == "pj") {
    paste0("MVE_PJ_SoilMoistureTemperature_", filter_to_year, ".csv")
  } else if (site == "jsav") {
    paste0("MVE_JSav_SoilMoistureTemperature_", filter_to_year, ".csv")
  } 
  
  # load MVE data ------------------------------------------------------------
  
  
  file_to_load <- if (site == "blue") {
    "MVE_Blue.dat"
  } else if (site == "black") {
    "MVE_Black.dat"
  } else if (site == "creosote") {
    "MVE_Creosote.dat"
  } else if (site == "pj") {
    "MVE_PJ_Table1_52423_MVC_2023_05_24_10_49_50.dat"
  } else if (site == "jsav") {
    "MVE_JSAV_Table1_52423_MVC_2023_05_24_12_46_59.dat"
  } else {
    NULL
  }
  
  mve <- read_mve_in(file_to_load) |> 
    select(-RECORD)
  
  
  # Note: For Blue, data prior to 2022-10-04 08:00:00 needs to be loaded from a file
  # because the data loggers were reset to capture data from some new sensors that
  # were installed. 
  
  # loading file for old MVE Blue data - 
  mve_blue_old <- if (site == "blue") {
    read_mve_in("MVE_Blue.dat.backup") |> 
      mutate(VWC_P2_12_NEW = as.numeric(NA),               # Need to add these new variables as NAs to old data in order to combine with newer data
             VWC_P2_22_NEW = as.numeric(NA),
             VWC_P2_37_NEW = as.numeric(NA)) |> 
      select(-RECORD)
  } else {
    NULL
  }
  
  
  mve_sub <- if (site == "blue") {
    rbind(mve, mve_blue_old) |> 
      arrange(TIMESTAMP) |> 
      unique() |> 
      filter(year(TIMESTAMP) == filter_to_year)
  } else {
    mve |> 
      arrange(TIMESTAMP) |> 
      unique() |> 
      filter(year(TIMESTAMP) == filter_to_year)
  }
  
  
  
  
  mve_sub_long <- if (site == "blue") {
    mve_sub |> 
      pivot_longer(-TIMESTAMP, names_to = "sensor_id") |> 
      separate(sensor_id, into = c("sensor", "plot", "depth", "new"), sep = "_", remove = FALSE) 
  } else if (site == "black") {
    mve_sub |> 
      pivot_longer(-TIMESTAMP, names_to = "sensor_id") |> 
      separate(sensor_id, into = c("plot", "depth", "sensor", "avg"), sep = "_", remove = FALSE)
  } else if (site == "creosote") {
    mve_sub |> 
      pivot_longer(-TIMESTAMP, names_to = "sensor_id") |> 
      separate(sensor_id, into = c("sensor", "piece1", "piece2", "piece3", "avg"), sep = "_", remove = FALSE) |> 
      mutate(plot1split = ifelse(piece1 %in% c(2, 3), NA, piece1),
             plot2split = ifelse(piece2 %in% c(12, 22, 37), NA, piece2),
             depth1split = ifelse(piece2 %in% c(12, 22, 37), piece2, NA),
             depth2split = ifelse(piece3 %in% c(12, 22, 37), piece3, NA),
             plot_extra = ifelse(piece1 %in% c(2, 3), piece1, NA),
             plot = ifelse((!is.na(plot1split) & is.na(plot2split)), plot1split, plot2split),
             depth = ifelse((!is.na(depth1split) & is.na(depth2split)), depth1split, depth2split)) |> 
      select(-c(avg, piece1, piece2, piece3, plot1split, plot2split, depth1split, depth2split))
  } else if (site == "pj") {
    mve_sub |> 
      pivot_longer(-TIMESTAMP, names_to = "sensor_id") |> 
      separate(sensor_id, into = c("sensor", "piece1", "piece2", "piece3", "piece4"), sep = "_", remove = FALSE) |> 
      mutate(plot1split = ifelse(piece1 %in% c(2, 3), NA, piece1),
             plot2split = ifelse(piece2 %in% c(12, 22, 37), NA, piece2),
             depth1split = ifelse(piece2 %in% c(12, 22, 37), piece2, NA),
             depth2split = ifelse(piece3 %in% c(12, 22, 37), piece3, NA),
             plot_extra = ifelse(piece1 %in% c(2, 3), piece1, NA),
             plot = ifelse((!is.na(plot1split) & is.na(plot2split)), plot1split, plot2split),
             depth = ifelse((!is.na(depth1split) & is.na(depth2split)), depth1split, depth2split)) |> 
      select(-c(piece1, piece2, piece3, piece4, plot1split, plot2split, depth1split, depth2split))
  } else if (site == "jsav") {
    mve_sub |> 
      pivot_longer(-TIMESTAMP, names_to = "sensor_id") |> 
      separate(sensor_id, into = c("sensor", "piece1", "piece2", "piece3", "piece4"), sep = "_", remove = FALSE) |> 
      mutate(plot1split = ifelse(piece1 %in% c(2, 3), NA, piece1),
             plot2split = ifelse(piece2 %in% c(12, 22, 37), NA, piece2),
             depth1split = ifelse(piece2 %in% c(12, 22, 37), piece2, NA),
             depth2split = ifelse(piece3 %in% c(12, 22, 37), piece3, NA),
             plot_extra = ifelse(piece1 %in% c(2, 3), piece1, NA),
             plot = ifelse((!is.na(plot1split) & is.na(plot2split)), plot1split, plot2split),
             depth = ifelse((!is.na(depth1split) & is.na(depth2split)), depth1split, depth2split)) |> 
      select(-c(piece1, piece2, piece3, piece4, plot1split, plot2split, depth1split, depth2split))
  } else {
    NULL
  }
    
  write_csv(mve_sub_long, paste0(folder_out, sub_file_name))

  return(paste("Data processing complete for site", site, "for year", year_to_process))
  
  
}




# Note: you will get a warning message when running the function because of how the
# raw data is formatted and needs to be processed.

# running these functions writes processed data to the output folder - only need to do once
# for prior years, but need to run the current year each time you get new, updated raw data
process_mve("blue", 2023)
process_mve("blue", 2022)
process_mve("blue", 2021)
process_mve("blue", 2020)
process_mve("blue", 2019)
process_mve("blue", 2018)

sm_t_18 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2018.csv")
sm_t_19 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2019.csv")
sm_t_20 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2020.csv")
sm_t_21 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2021.csv")
sm_t_22 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2022.csv")
sm_t_23 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2023.csv")

```

Then, clean-up climate data from EDI for met station 50 (near site). This results in **"met_50.csv"**

```{r climate data hidden}
#| eval: false # Do not evaluate this chunk
#| echo: false

met_00_04 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sev.1.17&entityid=371109f8068b35cf65edc8ba4237c8bd")
met_05_09 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sev.1.17&entityid=e326dbe48c0cdc5b91496a469a50e36d")
met_10_14 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sev.1.17&entityid=011fd6eb9726321cace6c72b50cb8056")
met_15_19 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sev.1.17&entityid=76922a0b041ac5ab05be6132ff7f90d7")
met_20_23 <- read_csv("https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sev.1.17&entityid=65056476604ff22cb44dcc3d3bebfd2a")

unique(met_00_04$StationID)
met_00_04_50 <- met_00_04 %>% 
  filter(StationID == 50) %>% 
  select(StationID,
         Date_Time,
         Date,
         Year,
         Month,
         Day_of_Month,
         Julian_Day,
         Hour,
         Temp_C,
         Min_Temp_C,
         Max_Temp_C,
         Precipitation)
unique(met_00_04_50$StationID)
str(met_00_04_50)

unique(met_05_09$StationID)
met_05_09_50 <- met_05_09 %>% 
  filter(StationID == 50) %>% 
  select(StationID,
         Date_Time,
         Date,
         Year,
         Month,
         Day_of_Month,
         Julian_Day,
         Hour,
         Temp_C,
         Min_Temp_C,
         Max_Temp_C,
         Precipitation)
unique(met_05_09_50$StationID)

unique(met_10_14$StationID)
met_10_14_50 <- met_10_14 %>% 
  filter(StationID == 50) %>% 
  select(StationID,
         Date_Time,
         Date,
         Year,
         Month,
         Day_of_Month,
         Julian_Day,
         Hour,
         Temp_C,
         Min_Temp_C,
         Max_Temp_C,
         Precipitation)
unique(met_10_14_50$StationID)

unique(met_15_19$StationID)
met_15_19_50 <- met_15_19 %>% 
  filter(StationID == 50) %>% 
  select(StationID,
         Date_Time,
         Date,
         Year,
         Month,
         Day_of_Month,
         Julian_Day,
         Hour,
         Temp_C,
         Min_Temp_C,
         Max_Temp_C,
         Precipitation)
unique(met_15_19_50$StationID)

unique(met_20_23$StationID)
met_20_23_50 <- met_20_23 %>% 
  filter(StationID == 50) %>% 
  select(StationID,
         Date_Time,
         Date,
         Year,
         Month,
         Day_of_Month,
         Julian_Day,
         Hour,
         Temp_C,
         Min_Temp_C,
         Max_Temp_C,
         Precipitation)
 unique(met_20_23_50$StationID)

 met_00_23_50 <- rbind(met_00_04_50,
      met_05_09_50,
      met_10_14_50,
      met_15_19_50,
      met_20_23_50)
 
 write_csv(met_00_23_50, "met_50.csv")
```

Lastly, I created a survival dataset taking the last observation day (+7 days, because assuming it didn't die on the last day it was observed) and subtracting first observation day. If Status = 1, it died. If Status = 0, it was still alive at time of last census. This results in the file **"surv_19_23.csv"**

```{r}
#| eval: false
#| echo: false

str(blue_19_23_long_raw)
head(blue_19_23_long_raw)

# need a new dataset taking the first date of germination and first date of zero

# could start by filtering only those TPs that germinated at all

TPs <- unique(blue_19_23_long_raw$TP_ID)

TP_list <- blue_19_23_long_raw %>% 
  filter(Germ.binom == 1)

TP_list <- unique(TP_list$TP_ID)

str(TP_list)

blue_19_23_surv <- blue_19_23_long_raw %>%
  group_by(TP_ID) %>%
  filter(any(TP_ID %in% c(TP_list))) %>% 
  ungroup()
```

```{r}
#| eval: false
#| echo: false
# Check that these accurately represent the last day of the survey for each cohort:

max_dates <- blue_19_23_long_raw %>% 
  group_by(Add_Year) %>% 
  summarise(max_date = max(Obs_Date))

max_dates[which(max_dates$Add_Year == 2019),2]

last_2019 <- max_dates[which(max_dates$Add_Year == 2019),2]
last_2020 <- max_dates[which(max_dates$Add_Year == 2020),2]
last_2021 <- max_dates[which(max_dates$Add_Year == 2021),2]
last_2022 <- max_dates[which(max_dates$Add_Year == 2022),2]
last_2023 <- max_dates[which(max_dates$Add_Year == 2023),2]

surv <- blue_19_23_surv %>%
  group_by(TP_ID) %>%
  subset(Germ.binom>0) %>%
  mutate(Species = Species,
          Add_Year = Add_Year,
          Plot = Plot,
          Corner = Corner,
          TP_ID = as.factor(TP_ID),
          Germ.binom = 1,
          Germ_date = min(Obs_Date),
          Last_Obs = max(Obs_Date),
          Death_date = max(Obs_Date)+7,
          Surv_days =
            as.numeric(difftime((max(Obs_Date)+7),
                                min(Obs_Date),
                                units = "days")),
          Status = 1
  ) %>%
  # specify if death was observed (status 1) 
  # or survival time was censored (status 0), seedling still alive at last census
  mutate(Status=
           case_when(
             Add_Year == 2020 & Last_Obs == last_2020 ~ 0,
             Add_Year == 2021 & Last_Obs == last_2021 ~ 0,
             Add_Year == 2022 & Last_Obs == last_2022 ~ 0,
             Add_Year == 2023 & Last_Obs == last_2023 ~ 0,
             .default = 1
           )) %>%
  select(TP_ID,
         Add_Year,
         Plot,
         Species,
         Germ_date,
         Last_Obs,
         Death_date,
         Surv_days,
         Status) %>% 
  distinct()

summary(surv)

write_csv(surv, "surv_19_23.csv")

```

## Read in Cleaned Data

These are all the datasets cleaned from above.

```{r}
#| warning: false
#| message: false

# reduced to only first germ
blue_19_23 <- read_csv("germ_19_23.csv") 

# All binomial observations from first germ through survival
blue_19_23_long_raw <- read_csv("germ_19_23_long_raw.csv") 

# This dataset is limited to planting year and planting year + 1. 
# Not raw data. Did the toothpick germinate in Year X? Yes no
bluebyyear <- read_csv("blue_year_cohorts.csv")

# This dataset is limited to toothpicks in planting year and planting 
# year + 1. Further, it's every toothpick (from present year or present 
# year +1) that's able to germinate for one of 8 large rainfall events. 
germ_sm <- read_csv("germ_events_sm.csv")

surv <- read_csv("surv_19_23.csv")

trts<-read.csv("MVE_treatments_allsites_2023_adj.csv")

sm_t_18 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2018.csv")
sm_t_19 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2019.csv")
sm_t_20 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2020.csv")
sm_t_21 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2021.csv")
sm_t_22 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2022.csv")
sm_t_23 <- read_csv("MVE-seedsMVE_PlainsGrassland_SoilMoistureTemperature_2023.csv")

met_00_23_50 <- read_csv("met_50.csv")
```

### Visualize rain + soil moisture for events

```{r}
#| warning: false
#| message: false
#| echo: false

# str(germ_sm)
# head(germ_sm)
events <- as.Date(unique(germ_sm$Obs_Date))

# Need to merge this data set with soil moisture and temperature metrics which are in their own years (sm_t_18-sm_t_23)

# head(sm_t_18)

# We can merge all soil moisture frames and then filter by event dates
sm_t <- rbind(sm_t_18,
      sm_t_19,
      sm_t_20,
      sm_t_21,
      sm_t_22,
      sm_t_23)

# Let's explore what the data looks like around a rain event
# Because those are the germination events but not necessarily the rain events, which could have been two to four weeks before

# Break out timestamp column into date and time
# head(sm_t$TIMESTAMP)
sm_t$Date <- date(sm_t$TIMESTAMP)
# head(sm_t$Date)

# Filter sm_t by each date and 28 days before and two days after. 
# (perfect opp for a loop)

sm_t_event_1 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[1]-28) & Date < (events[1]+2))) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_1") %>% 
  ungroup()

sm_event_sum_1 <- sm_t_event_1 %>% 
  group_by(Date) %>% 
  summarise(avg_sm = mean(value, na.rm = TRUE),
            max_sm = max(value, na.rm = TRUE))

sm_t_event_2 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[2]-28) & Date < (events[2]+2))) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_2") %>% 
  ungroup()
unique(sm_t_event_2$Date)

sm_event_sum_2 <- sm_t_event_2 %>% 
  group_by(Date) %>% 
  summarise(avg_sm = mean(value, na.rm = TRUE),
            max_sm = max(value, na.rm = TRUE))

sm_t_event_3 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[3]-28) & Date < (events[3]+2))) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_3") %>% 
  ungroup()
unique(sm_t_event_3$Date)

sm_event_sum_3 <- sm_t_event_3 %>% 
  group_by(Date) %>% 
  summarise(avg_sm = mean(value, na.rm = TRUE),
            max_sm = max(value, na.rm = TRUE))

sm_t_event_4 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[4]-28) & Date < (events[4]+2))) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_4") %>% 
  ungroup()
unique(sm_t_event_4$Date)

sm_event_sum_4 <- sm_t_event_4 %>% 
  group_by(Date) %>% 
  summarise(avg_sm = mean(value, na.rm = TRUE),
            max_sm = max(value, na.rm = TRUE))

sm_t_event_5 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[5]-28) & Date < (events[5]+2))) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_5") %>% 
  ungroup()
unique(sm_t_event_5$Date)

sm_event_sum_5 <- sm_t_event_5 %>% 
  group_by(Date) %>% 
  summarise(avg_sm = mean(value, na.rm = TRUE),
            max_sm = max(value, na.rm = TRUE))

sm_t_event_6 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[6]-28) & Date < (events[6]+2))) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_6") %>% 
  ungroup()
unique(sm_t_event_6$Date)

sm_event_sum_6 <- sm_t_event_6 %>% 
  group_by(Date) %>% 
  summarise(avg_sm = mean(value, na.rm = TRUE),
            max_sm = max(value, na.rm = TRUE))

# Soil moisture data ends at 2023-08-07 so only 6 dates
# I wonder if we can actually predict germination form rainfall for the last two events

# Filter met station data by each date and 14 days before and after. Graph rainfall total per day for 28 days, with each germ event as it's own facet in a facet grid

# summary(met_00_23_50)

met_event_1 <- met_00_23_50 %>%
  group_by(Date) %>%
  filter(any(Date > (events[1]-28) & Date < (events[1]+2))) %>%
  ungroup()

met_event_sum_1 <- met_event_1 %>% 
  group_by(Date) %>% 
  summarise(sum_pp = sum(Precipitation, na.rm = TRUE))

met_event_2 <- met_00_23_50 %>%
  group_by(Date) %>%
  filter(any(Date > (events[2]-28) & Date < (events[2]+2))) %>%
  ungroup()

met_event_sum_2 <- met_event_2 %>% 
  group_by(Date) %>% 
  summarise(sum_pp = sum(Precipitation, na.rm = TRUE))

met_event_3 <- met_00_23_50 %>%
  group_by(Date) %>%
  filter(any(Date > (events[3]-28) & Date < (events[3]+2))) %>%
  ungroup()

met_event_sum_3 <- met_event_3 %>% 
  group_by(Date) %>% 
  summarise(sum_pp = sum(Precipitation, na.rm = TRUE))

met_event_4 <- met_00_23_50 %>%
  group_by(Date) %>%
  filter(any(Date > (events[4]-28) & Date < (events[4]+2))) %>%
  ungroup()

met_event_sum_4 <- met_event_4 %>% 
  group_by(Date) %>% 
  summarise(sum_pp = sum(Precipitation, na.rm = TRUE))

met_event_5 <- met_00_23_50 %>%
  group_by(Date) %>%
  filter(any(Date > (events[5]-28) & Date < (events[5]+2))) %>%
  ungroup()

met_event_sum_5 <- met_event_5 %>% 
  group_by(Date) %>% 
  summarise(sum_pp = sum(Precipitation, na.rm = TRUE))

met_event_6 <- met_00_23_50 %>%
  group_by(Date) %>%
  filter(any(Date > (events[6]-28) & Date < (events[6]+2))) %>%
  ungroup()

met_event_sum_6 <- met_event_6 %>% 
  group_by(Date) %>% 
  summarise(sum_pp = sum(Precipitation, na.rm = TRUE))
```
These graphs show the 6 germination events (no soil moisture data for 2023) from 2019-2022. Vertical black line is germination event (Observation Date). Shows precipittion (yellow), average daily soil moisture (purple), and maximum daily soil moisture (turquoise) for the 28 days leading up to the Observation date.

```{r}
#| echo: false
#| warning: false

# I want 6 graphs, with two axes, soil moisture one and precip on the other. Two lines are max and avg sm and one is total daily precip. And a vertical line at the Obs_Date and maximum either soil moisture or precip. Go back and go 28 days back and 2 days forward

event1 <- left_join(sm_event_sum_1, met_event_sum_1, by = join_by(Date))
event2 <- left_join(sm_event_sum_2, met_event_sum_2, by = join_by(Date))
event3 <- left_join(sm_event_sum_3, met_event_sum_3, by = join_by(Date))
event4 <- left_join(sm_event_sum_4, met_event_sum_4, by = join_by(Date))
event5 <- left_join(sm_event_sum_5, met_event_sum_5, by = join_by(Date))
event6 <- left_join(sm_event_sum_6, met_event_sum_6, by = join_by(Date))
str(event1)
# colorblind friendly colors
colors <- viridis(3)

coeff <- max(event1$sum_pp)/max(event1$max_sm)
event1_plot <- ggplot(event1, aes(x = Date)) + 
  geom_point(aes(y = avg_sm), size = 1.5, color = colors[1]) +  
  geom_line(aes(y = avg_sm), size = 1.5, color = colors[1]) +
  geom_point(aes(y = max_sm), size = 1.5, color = colors[2]) +  
  geom_line(aes(y = max_sm), size = 1.5, color = colors[2]) +
  geom_point(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +  
  geom_line(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +
  geom_vline(xintercept = events[1]) +
  #geom_line(aes(y = mean_pp), size = 1.5, color = '#00BFC4') + 
 # geom_line(aes(y = mean_max_t/coeff), size = 1.5, color = '#F8766D') +
  #geom_line(aes(y = mean_min_t/coeff), size = 1.5, color = '#C77CFF') +
  labs(
    #title = "Monthly Climate Averages from 2000-2023 at Great Plains Grassland Meteorological Station",
       x = "Date") +
  theme_bw() +
  theme(plot.title = element_text(size = 11),
        axis.title.y = element_text(color = colors[1], size=9),
        axis.title.y.right = element_text(color = colors[3], size=9),
        axis.title.x = element_text(size = 9),
        axis.text = element_text(size = 9)) +
  scale_x_date(date_breaks="1 week") +
  # scale_x_continuous(breaks=seq(0,13,by=1)) +
  scale_y_continuous(
    limits=c(0.0,0.3),
    name = "Volumetric Water Content", # Features of the first axis
    sec.axis = sec_axis( trans=~.*coeff, name="Daily Total Precipitation (mm)")) # Add 2nd axis & specify features
event1_plot
```

```{r}
ggsave("rain_event_1.jpg", event1_plot)

coeff <- max(event2$sum_pp)/max(event2$max_sm)
event2_plot <- ggplot(event2, aes(x = Date)) + 
  geom_point(aes(y = avg_sm), size = 1.5, color = colors[1]) +  
  geom_line(aes(y = avg_sm), size = 1.5, color = colors[1]) +
  geom_point(aes(y = max_sm), size = 1.5, color = colors[2]) +  
  geom_line(aes(y = max_sm), size = 1.5, color = colors[2]) +
  geom_point(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +  
  geom_line(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +
  geom_vline(xintercept = events[2]) +
  #geom_line(aes(y = mean_pp), size = 1.5, color = '#00BFC4') + 
 # geom_line(aes(y = mean_max_t/coeff), size = 1.5, color = '#F8766D') +
  #geom_line(aes(y = mean_min_t/coeff), size = 1.5, color = '#C77CFF') +
  labs(
    #title = "Monthly Climate Averages from 2000-2023 at Great Plains Grassland Meteorological Station",
       x = "Date") +
  theme_bw() +
  theme(plot.title = element_text(size = 11),
        axis.title.y = element_text(color = colors[1], size=9),
        axis.title.y.right = element_text(color = colors[3], size=9),
        axis.title.x = element_text(size = 9),
                axis.text = element_text(size = 9)) +
  scale_x_date(date_breaks="1 week") +
  # scale_x_continuous(breaks=seq(0,13,by=1)) +
  scale_y_continuous(
    limits=c(0.0,0.3),
    name = "Volumetric Water Content", # Features of the first axis
    sec.axis = sec_axis( trans=~.*coeff, name="Daily Total Precipitation (mm)")) # Add 2nd axis & specify features
event2_plot

ggsave("rain_event_2.jpg", event2_plot)

coeff <- max(event3$sum_pp)/max(event3$max_sm)
event3_plot <- ggplot(event3, aes(x = Date)) + 
  geom_point(aes(y = avg_sm), size = 1.5, color = colors[1]) +  
  geom_line(aes(y = avg_sm), size = 1.5, color = colors[1]) +
  geom_point(aes(y = max_sm), size = 1.5, color = colors[2]) +  
  geom_line(aes(y = max_sm), size = 1.5, color = colors[2]) +
  geom_point(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +  
  geom_line(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +
  geom_vline(xintercept = events[3]) +
  #geom_line(aes(y = mean_pp), size = 1.5, color = '#00BFC4') + 
 # geom_line(aes(y = mean_max_t/coeff), size = 1.5, color = '#F8766D') +
  #geom_line(aes(y = mean_min_t/coeff), size = 1.5, color = '#C77CFF') +
  labs(
    #title = "Monthly Climate Averages from 2000-2023 at Great Plains Grassland Meteorological Station",
       x = "Date") +
  theme_bw() +
  theme(plot.title = element_text(size = 11),
        axis.title.y = element_text(color = colors[1], size=9),
        axis.title.y.right = element_text(color = colors[3], size=9),
        axis.title.x = element_text(size = 9),
        axis.text = element_text(size = 9)) +
  scale_x_date(date_breaks="1 week") +
  # scale_x_continuous(breaks=seq(0,13,by=1)) +
  scale_y_continuous(
    limits=c(0.0,0.3),
    name = "Volumetric Water Content", # Features of the first axis
    sec.axis = sec_axis( trans=~.*coeff, name="Daily Total Precipitation (mm)")) # Add 2nd axis & specify features
event3_plot

ggsave("rain_event_3.jpg", event3_plot)

coeff <- max(event4$sum_pp)/max(event4$max_sm)
event4_plot <- ggplot(event4, aes(x = Date)) + 
  geom_point(aes(y = avg_sm), size = 1.5, color = colors[1]) +  
  geom_line(aes(y = avg_sm), size = 1.5, color = colors[1]) +
  geom_point(aes(y = max_sm), size = 1.5, color = colors[2]) +  
  geom_line(aes(y = max_sm), size = 1.5, color = colors[2]) +
  geom_point(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +  
  geom_line(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +
  geom_vline(xintercept = events[4]) +
  #geom_line(aes(y = mean_pp), size = 1.5, color = '#00BFC4') + 
 # geom_line(aes(y = mean_max_t/coeff), size = 1.5, color = '#F8766D') +
  #geom_line(aes(y = mean_min_t/coeff), size = 1.5, color = '#C77CFF') +
  labs(
    #title = "Monthly Climate Averages from 2000-2023 at Great Plains Grassland Meteorological Station",
       x = "Date") +
  theme_bw() +
  theme(plot.title = element_text(size = 11),
        axis.title.y = element_text(color = colors[1], size=9),
        axis.title.y.right = element_text(color = colors[3], size=9),
        axis.title.x = element_text(size = 9),
        axis.text = element_text(size = 9)) +
  scale_x_date(date_breaks="1 week") +
  # scale_x_continuous(breaks=seq(0,13,by=1)) +
  scale_y_continuous(
    limits=c(0.0,0.3),
    name = "Volumetric Water Content", # Features of the first axis
    sec.axis = sec_axis( trans=~.*coeff, name="Daily Total Precipitation (mm)")) # Add 2nd axis & specify features
event4_plot

ggsave("rain_event_4.jpg", event4_plot)

coeff <- max(event5$sum_pp)/max(event5$max_sm)
event5_plot <- ggplot(event5, aes(x = Date)) + 
  geom_point(aes(y = avg_sm), size = 1.5, color = colors[1]) +  
  geom_line(aes(y = avg_sm), size = 1.5, color = colors[1]) +
  geom_point(aes(y = max_sm), size = 1.5, color = colors[2]) +  
  geom_line(aes(y = max_sm), size = 1.5, color = colors[2]) +
  geom_point(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +  
  geom_line(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +
  geom_vline(xintercept = events[5]) +
  #geom_line(aes(y = mean_pp), size = 1.5, color = '#00BFC4') + 
 # geom_line(aes(y = mean_max_t/coeff), size = 1.5, color = '#F8766D') +
  #geom_line(aes(y = mean_min_t/coeff), size = 1.5, color = '#C77CFF') +
  labs(
    #title = "Monthly Climate Averages from 2000-2023 at Great Plains Grassland Meteorological Station",
       x = "Date") +
  theme_bw() +
  theme(plot.title = element_text(size = 11),
        axis.title.y = element_text(color = colors[1], size=9),
        axis.title.y.right = element_text(color = colors[3], size=9),
        axis.title.x = element_text(size = 9),
        axis.text = element_text(size = 9)) +
  scale_x_date(date_breaks="1 week") +
  # scale_x_continuous(breaks=seq(0,13,by=1)) +
  scale_y_continuous(
    limits=c(0.0,0.3),
    name = "Volumetric Water Content", # Features of the first axis
    sec.axis = sec_axis( trans=~.*coeff, name="Daily Total Precipitation (mm)")) # Add 2nd axis & specify features
event5_plot

ggsave("rain_event_5.jpg", event5_plot)

# factor to multiply 1st y-axis
coeff <- max(event6$sum_pp)/max(event6$max_sm)
event6_plot <- ggplot(event6, aes(x = Date)) + 
  geom_point(aes(y = avg_sm), size = 1.5, color = colors[1]) +  
  geom_line(aes(y = avg_sm), size = 1.5, color = colors[1]) +
  geom_point(aes(y = max_sm), size = 1.5, color = colors[2]) +  
  geom_line(aes(y = max_sm), size = 1.5, color = colors[2]) +
  geom_point(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +  
  geom_line(aes(y = sum_pp/coeff), size = 1.5, color = colors[3]) +
  geom_vline(xintercept = events[6]) +
  #geom_line(aes(y = mean_pp), size = 1.5, color = '#00BFC4') + 
 # geom_line(aes(y = mean_max_t/coeff), size = 1.5, color = '#F8766D') +
  #geom_line(aes(y = mean_min_t/coeff), size = 1.5, color = '#C77CFF') +
  labs(
    #title = "Monthly Climate Averages from 2000-2023 at Great Plains Grassland Meteorological Station",
       x = "Date") +
  theme_bw() +
  theme(plot.title = element_text(size = 11),
        axis.title.y = element_text(color = colors[1], size=9),
        axis.title.y.right = element_text(color = colors[3], size=9),
        axis.title.x = element_text(size = 9),
        axis.text = element_text(size = 9)) +
  scale_x_date(date_breaks="1 week") +
  # scale_x_continuous(breaks=seq(0,13,by=1)) +
  scale_y_continuous(
    limits=c(0.0,0.3),
    name = "Volumetric Water Content", # Features of the first axis
    sec.axis = sec_axis( trans=~.*coeff, name="Daily Total Precipitation (mm)")) # Add 2nd axis & specify features
event6_plot

ggsave("rain_event_6.jpg", event6_plot)

```
This means we could characterize the soil moisture conditions that led to germination in a few different ways.

Consider taking the average soil moisture from the maximum soil moisture time to the germ date and the maximum leading up to it, and we see which is a better predictor of germination because drought plots might experience a similar maximum but not retain soil moisture, and the retention is actually the key to triggering mass germination. If this is true the average would be a better predictor.

### Create soil moisture variables

Four measurements of soil moisture for model comparison:

- Average maximum soil moisture in 7 days leading up to census date
- Average soil moisture in 7 days leading up to census data 
- Maximum soil moisture in 28 days leading up to census date 
- Average maximum soil moisture from date of maximum to census date

```{r}
#| eval: false
#| echo: false

events
head(sm_t)

sm_event_1 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[1]-28) & Date < events[1])) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_1",
         Obs_Date = events[1]) %>% 
  ungroup()

sm_event_2 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[2]-28) & Date < events[2])) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_2",
         Obs_Date = events[2]) %>% 
  ungroup()

sm_event_3 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[3]-28) & Date < events[3])) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_3",
         Obs_Date = events[3]) %>% 
  ungroup()

sm_event_4 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[4]-28) & Date < events[4])) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_4",
         Obs_Date = events[4]) %>% 
  ungroup()

sm_event_5 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[5]-28) & Date < events[5])) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_5",
         Obs_Date = events[5]) %>% 
  ungroup()

sm_event_6 <- sm_t %>%
  group_by(Date) %>%
  filter(any(Date > (events[6]-28) & Date < events[6])) %>%
  filter(sensor == "VWC" & depth == 12) %>% 
  mutate(event = "event_6",
         Obs_Date = events[6]) %>% 
  ungroup()

sm_events <- rbind(
  sm_event_1,
  sm_event_2,
  sm_event_3,
  sm_event_4,
  sm_event_5,
  sm_event_6
)
# Separate plot column to just have number
sm_events$Plot <- as.numeric(sub('.', '', sm_events$plot))

head(sm_events)
unique(sm_events$value)
```

```{r}
#| eval: false
#| echo: false

unique(met_00_23_50$Precipitation)
met_day_sum <- met_00_23_50 %>%
  group_by(Date) %>%
  summarise(sum_day_pp = sum(Precipitation, na.rm = TRUE))

unique(sm_events$Obs_Date)

sm_pp_events <- left_join(sm_events, met_day_sum, by = join_by(Date))
summary(sm_pp_events)
max(sm_pp_events$value, na.rm = TRUE)
unique(sm_pp_events$Obs_Date)

nanas <- sm_pp_events[which(is.na(sm_pp_events$value) == TRUE),]
summary(nanas)
table(nanas$Plot,nanas$Date)

# remove all rows with NA in the "value" column
sm_pp_events_narm <- sm_pp_events[!is.na(sm_pp_events$value),]
unique(sm_pp_events_narm$Obs_Date)

sm_event_sum <- sm_pp_events_narm %>% 
  group_by(Date, Plot) %>% 
  mutate(avg_day_sm = mean(value, na.rm = TRUE),
            max_day_sm = max(value, na.rm = TRUE),
            Obs_Date = Obs_Date,
            sum_day_pp = sum_day_pp) %>% 
  select(Date,
         Obs_Date,
         Plot,
         sum_day_pp,
         avg_day_sm,
         max_day_sm) %>% 
  distinct()
head(sm_event_sum)
summary(sm_event_sum)
unique(sm_event_sum$Obs_Date)

# Do average of maximums for Obs_date-7
sm_event_avg_7_max <- sm_event_sum %>% 
  group_by(Obs_Date, Plot) %>%
  filter(any(Date > (Obs_Date-7) & Date < Obs_Date)) %>%
  summarise(avg_7_max = mean(max_day_sm))

# True average of Obs_Date-7
sm_event_avg_7 <- sm_events %>% 
  group_by(Obs_Date, Plot) %>% 
  filter(any(Date > (Obs_Date-7) & Date < Obs_Date)) %>%
  summarise(avg_7 = mean(value, na.rm = TRUE))

sm_event_vars <- full_join(sm_event_avg_7_max, sm_event_avg_7, by = join_by(Obs_Date, Plot))

# average of maximums for Obs_Date-Maximum Date
pp_events_sum <- sm_pp_events_narm %>% 
  group_by(Obs_Date) %>% 
  summarise(max_pp = max(sum_day_pp),
            Mons_Date = Date[which(sum_day_pp == max(sum_day_pp))])

sm_pp_event_sum <- left_join(sm_event_sum,pp_events_sum, by = join_by(Obs_Date))

sm_event_avg_max_mons <- sm_pp_event_sum %>% 
  group_by(Obs_Date,Plot) %>% 
  filter(any(Date > (Obs_Date-Mons_Date) & Date < Obs_Date)) %>%
  summarise(avg_mons_max = mean(max_day_sm, na.rm = TRUE))

sm_event_vars_2 <- full_join(sm_event_vars, sm_event_avg_max_mons, by = join_by(Obs_Date, Plot))

# Maximum on maximum date
sm_event_max_mons <- sm_pp_event_sum %>% 
  group_by(Obs_Date,Plot) %>% 
  filter(any(Date > (Obs_Date-Mons_Date) & Date < Obs_Date)) %>%
  summarise(mons_max = max(max_day_sm, na.rm = TRUE))

## 7-5 is fixed!
sm_event_vars_3 <- full_join(sm_event_vars_2, sm_event_max_mons, by = join_by(Obs_Date, Plot))

write_csv(sm_event_vars_3, "sm_event_vars.csv")

```

```{r}
#| warning: false

sm_event_vars <- read_csv("sm_event_vars.csv")
head(sm_event_vars)
```

## Data Exploration

Our data objects are 
`blue_19_23`,
`blue_19_23_long_raw`,
`bluebyyear`
`trts`, 
`sm_t_18`:`sm_t_23`, 
`met_00_23_50`


```{r}
summary(blue_19_23)
# head(blue_19_23)
# str(blue_19_23)
sum(blue_19_23$Germ.binom, na.rm = TRUE)/(nrow(blue_19_23)-1)
```

Overall germination rate of 13.5% across five years, both treatments, both species.

```{r}
summary(bluebyyear)

# drop NAs in Add-Year, Obs_Date, and Germ_binom. Investigate later if you want
bluebyyear <- bluebyyear[!is.na(bluebyyear$Add_Year),]
bluebyyear <- bluebyyear[!is.na(bluebyyear$Obs_Date),]
bluebyyear <- bluebyyear[!is.na(bluebyyear$Germ.binom),]

bluebyyear$trial <- 1
bluebyyear %>% 
  group_by(Obs_Year) %>% 
  summarise(germ_prob = sum(Germ.binom)/sum(trial))
```

Highest germination rate in 2022 at 10%. Lowest in 2019 at 1%.

```{r}
# str(trts)

trts <- trts %>% 
  select(
    site,
    block,
    plot,
    mean_treatment,
    var_treatment_2019_m,
    var_treatment_2020_m,
    var_treatment_2021_m,
    var_treatment_2022_m,
    var_treatment_2023_m,
    var_treatment
  )

head(trts)
```

Treatments for mean-variance blue. Increased variance treatments flipped at random from 2019-2022. Adjusted treatments because year variance treatments reflect treatment changes for November of that year. So if a plot went from increase (+50% precipitation) in 2021 to decrease (-50%) in 2022, the decrease didn't happen until November of 2022. So monsoon rainfall for 2022 was actually under the "increase" treatment (+50%) in this example.

```{r}
# summary(sm_t_20)
head(sm_t_20)
```

Sensor data for 18/30 plots at mean-variance blue. sensor_id contains sensor type (temperature or volumentric water content), plot, and sensor depth (12, 22, or 37 cm).

```{r}
summary(met_00_23_50)
# head(met_00_23_50)
# str(met_00_23_50)
```

Hourly climate data from Met Station 50, limited to date and time, temperature, and precipitation.

Below are soil moisture averages leading up to census dates and germination data from major census events.

```{r}
str(sm_event_vars)
summary(sm_event_vars)
# avg_7_max is the average of daily maximums in the 7 days leading up to the census date
# avg_7 is the true average of soil moisture in the 7 days leading up to the census date
# avg_mons_max is the average of daily maximum soil moisture from the date of the largest monsoon event in the month prior leading up to the germination event
# mons_max is the maximum soil moisture after the monsoon event

str(germ_sm)
summary(germ_sm)
```

## Characterize and Graph Climate

The climate data are collected from meteorological stations at the Sevilleta NWR. These data come from met station 50, which is the nearest station to MVE Blue. Data began in 2000 and continues through 2023. Data is organized by date and time, temperature in celsius per hour, and minimum and maximum temperature for hour, total precipitation per hour in millimeters. I'm interested in the average range of temperatures for each season and the average annual and seasonal precipitation. Data comes from here(<https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-sev.1.17>)

I want a graph where the x-axis is days of the year and there are three lines, each with confidence bands: average daily precip, daily high temperature, daily low temperature.

```{r}
#| message: false
#| warning: false
#| echo: false

# str(met_00_23_50)

# Create Month-Yr variable
met_00_23_50$Month_Yr <- format(as.Date(met_00_23_50$Date), "%Y-%m")

# convert temperatures to fahrenheit
met_00_23_50$Min_Temp_F <- ((met_00_23_50$Min_Temp_C)*(9/5)) + 32
met_00_23_50$Max_Temp_F <- ((met_00_23_50$Max_Temp_C)*(9/5)) + 32

# summarize climate data by Month and Year
clim_sum <- met_00_23_50 %>% 
  group_by(Month, Year) %>% 
  summarise(sum_pp = sum(Precipitation),
            daily_min = min(Min_Temp_F),
            daily_max = max(Max_Temp_F))

clim_sum_pp <- clim_sum %>% 
  group_by(Month) %>% 
  summarise(mean_pp = mean(sum_pp, na.rm = TRUE),
            pp_sd = sd(sum_pp, na.rm = TRUE)) %>% 
  mutate(pp_upper = mean_pp + 1*pp_sd,
         pp_lower = mean_pp - 1*pp_sd)

clim_sum_max_t <- clim_sum %>% 
  group_by(Month) %>% 
  summarise(mean_max_t = mean(daily_max, na.rm = TRUE),
            max_t_sd = sd(daily_max, na.rm = TRUE)) %>% 
  mutate(max_t_upper = mean_max_t + 1*max_t_sd,
         max_t_lower = mean_max_t - 1*max_t_sd)
            
clim_sum_min_t <- clim_sum %>% 
  group_by(Month) %>% 
  summarise(mean_min_t = mean(daily_min, na.rm = TRUE),
            min_t_sd = sd(daily_min, na.rm = TRUE)) %>% 
  mutate(min_t_upper = mean_min_t + 1*min_t_sd,
         min_t_lower = mean_min_t - 1*min_t_sd)

clim_sum_2 <- full_join(clim_sum_pp,clim_sum_max_t, by = join_by(Month))
clim_sum_3 <- full_join(clim_sum_2,clim_sum_min_t, by = join_by(Month))
```

```{r}
#| message: false
#| warning: false
#| echo: false

# Prep for figure
# str(clim_sum_3)

# Range for temperature axis
max(clim_sum_max_t$mean_max_t)
min(clim_sum_min_t$mean_min_t)

# colorblind friendly colors
colors <- viridis(3)

# factor to multiply 1st y-axis
coeff <- 2

clim_plot <- ggplot(clim_sum_3, aes(x = Month)) + 
  geom_point(aes(y = mean_pp), size = 1.5, color = colors[1]) +  
  # geom_smooth(aes(y = mean_pp), size = 1.5, color = colors[1]) +
  geom_point(aes(y = mean_max_t/coeff), size = 1.5, color = colors[2]) +  
  #geom_smooth(aes(y = mean_max_t/coeff), size = 1.5, color = colors[2]) +
  geom_point(aes(y = mean_min_t/coeff), size = 1.5, color = colors[2]) +  
  # geom_smooth(aes(y = mean_min_t/coeff), size = 1.5, color = colors[2]) +
  geom_line(aes(y = mean_pp), size = 1.5, color = colors[1]) + 
  #geom_ribbon(aes(ymin=pp_lower, ymax=pp_upper), linetype=2, alpha=0.1, color = colors[1]) +
  geom_line(aes(y = mean_max_t/coeff), size = 1.5, color = colors[2]) +
  #geom_ribbon(aes(ymin=max_t_lower/coeff, ymax=max_t_upper/coeff), linetype=2, alpha=0.1, color = colors[2]) +
  geom_line(aes(y = mean_min_t/coeff), size = 1.5, color = colors[2]) +
  #geom_ribbon(aes(ymin=min_t_lower/coeff, ymax=min_t_upper/coeff), linetype=2, alpha=0.1, color = colors[2]) +
  labs(
    #title = "Monthly Climate Averages from 2000-2023 at Great Plains Grassland Meteorological Station",
       x = "Month") +
  theme_bw() +
  theme(plot.title = element_text(size = 11),
        axis.title.y = element_text(color = colors[1], size=9),
        axis.title.y.right = element_text(color = colors[2], size=9),
        axis.title.x = element_text(size = 9),
        axis.text = element_text(size = 9)) +
  scale_x_continuous(
    breaks = seq_along(month.name), 
    labels = month.name
  ) +
  theme(
    axis.text.x = element_text(angle = 55, hjust = 1)) +
  scale_y_continuous(
    name = "Average Monthly Total Precipitation (mm)", # Features of the first axis
    sec.axis = sec_axis( trans=~.*coeff, name="Average Daily Temperature High and Low (F)")) # Add 2nd axis & specify features
clim_plot

ggsave("F1_MVEBlue_climate.jpg", clim_plot)

# Ribbons add 66% confidence interval around line but it needs work, the variation in precip is so high it distorts the graph. Could do 60% but that seems weird
```

Figure 1. Climate averages for Meteorological Station 50 near Mean-Variance Blue Experiment from 2000-2023. Purple dots represent total monthly precipitation in millimeters, averaged over 2000-2023. Turquoise dots represent monthly average daily minimum and maximum temperatures in Fahrenheit from 2000-2023.

## Simple model of germination using Year and Treatments

Make a generalized linear mixed model with a binomial or bernoulli distribution and corner, plot, and block, and maybe Year as random effects. Possible fixed effects are species, mean treatment, variance treatment, Year, annual rainfall, or monsoon rainfall.

You'll need to remove toothpicks in the NW corner in 2019 since those were planted among adult blue grama grass to test facilitation.

```{r}
#| message: false
#| warning: false

# reminder blue_19_23 is only whether each toothpick germinated or not over it's lifetime
#summary(blue_19_23)
#head(blue_19_23)
#str(blue_19_23)

# Overall germination rate
sum(blue_19_23$Germ.binom, na.rm = TRUE)/(nrow(blue_19_23)-1)
# Why did I subtract 1?
#head(trts)

# join treatments and germ dataset
trts$Plot <- trts$plot
blue_19_23_trt <- left_join(blue_19_23, trts, by = "Plot")

# prepare for model
# Remove toothpicks with Corner == NE and Add_Year == 2019
blue_19_23_trt_NE19rm <- 
  blue_19_23_trt %>%  
  filter(!(Add_Year == 2019 & Corner == "NE"))

# separate dataset by species
bluegrama <- 
  blue_19_23_trt_NE19rm %>% 
  filter(Species == "BLUE")

blackgrama <- 
  blue_19_23_trt_NE19rm %>% 
  filter(Species == "BLACK")
```

Try generalized linear mixed effects models for the simplest dataset blue_19_23. This considers what year the seeds were planted but not necessarily the year they germinated. This is only the probability of whether a given seed germinated or not over the 5 years.

```{r}
#| eval: true # Do evaluate this chunk
#| echo: true # Do show this chunk in the final rendered document

# Try both species together first
m0 <- glmer(Germ.binom ~ 1 + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blue_19_23_trt_NE19rm)

# ignore Add Year
m0b <- glmer(Germ.binom ~ 1 + (1|block/Plot/Corner), family = binomial, data = blue_19_23_trt_NE19rm)

# just mean treatment
m1 <- glmer(Germ.binom ~ mean_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blue_19_23_trt_NE19rm)

# just variance treatment
m2 <- glmer(Germ.binom ~ var_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blue_19_23_trt_NE19rm)

# just Species
m3 <- glmer(Germ.binom ~ Species + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blue_19_23_trt_NE19rm)

# mean and variance treatments
m4 <- glmer(Germ.binom ~ var_treatment + mean_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blue_19_23_trt_NE19rm)

# interaction between mean and variance
m5 <- glmer(Germ.binom ~ var_treatment + mean_treatment + mean_treatment*var_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blue_19_23_trt_NE19rm)

# just Add Year as a fixed effect
m6 <- glmer(Germ.binom ~ Add_Year + (1|block/Plot/Corner), family = binomial, data = blue_19_23_trt_NE19rm)

# test each model against null model
# lrtest(m0,m6)
# lrtest(m0b,m6)
ICtab(m0,m0b,m1,m2,m3,m4,m5,m6)
VarCorr(m0)
```

Temporal and spatial heterogeneity explain a lot of the data. Super not helpful to remove Add-Year as a random effect. Best models are m0, m1, m5, m2, m3, m4 (all very close and within 2 dAIC). Did not help to scale Add_year.

No differences by treatments, not including species as a factor.

Below, try models for each species.

```{r}
#| eval: true # Do evaluate this chunk
# try blue grama
g0 <- glmer(Germ.binom ~ 1 + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = bluegrama)

g1 <- glmer(Germ.binom ~ mean_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = bluegrama)

g2 <- glmer(Germ.binom ~ var_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = bluegrama)

g3 <- glmer(Germ.binom ~ var_treatment + mean_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = bluegrama)

g4 <- glmer(Germ.binom ~ var_treatment + mean_treatment + mean_treatment*var_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = bluegrama)

# test each model against null model
# lrtest(g0,g4)
ICtab(g0,g1,g2,g3,g4)
VarCorr(g0)
```

Null model is just as good as any other model (no significant predictors).

Try black grama below.

```{r}
#| eval: true # Do evaluate this chunk
# try black grama
e0 <- glmer(Germ.binom ~ 1 + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blackgrama)

e1 <- glmer(Germ.binom ~ mean_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blackgrama)

e2 <- glmer(Germ.binom ~ var_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blackgrama)

e3 <- glmer(Germ.binom ~ var_treatment + mean_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blackgrama)

e4 <- glmer(Germ.binom ~ var_treatment + mean_treatment + mean_treatment*var_treatment + (1|block/Plot/Corner) + (1|Add_Year), family = binomial, data = blackgrama)

# test each model against null mode
# lrtest(e0,e4)
ICtab(e0,e1,e2,e3,e4)
VarCorr(e0)
```

Mean and variance treatments are not significant predictors of germination for blue or black grama. The null model (constant germination) was the best fit for the data at this time.

Next steps: Try including Monsoon rainfall, total annual precip.

We care about Year in that it might interact with the treatment.

Try limiting to year planted or year after. So each "Observation Year" includes the seeds planted that year and the ungerminated seeds from the year prior.

## Year Cohort Model

Create new variables with meteorological data and treatments. Make treatments numeric.

```{r cohort rain year}
#| echo: false
# reminder that this dataset includes current year cohort and past year cohort, with germinated toothpicks removed. Not raw data, only whether a toothpick germinated or not
# head(bluebyyear)

# randomly select a TP ID and see how many times it shows up
# TP_IDs <- unique(bluebyyear$TP_ID)
# which(bluebyyear$TP_ID == sample(TP_IDs,1))
# numbers should show up once or twice

```

```{r}
#| echo: false
# merge with treatments
#head(trts)
blue_yr_trt <- left_join(bluebyyear,trts, by = join_by(plot))
#head(blue_yr_trt)

blue_yr_trt <- blue_yr_trt %>% 
  select(
    block,
    plot,
    Corner,
    Species,
    Row,
    Column,
    TP_ID,
    Add_Year,
    Obs_Date,
    Obs_Year,
    Germ.binom,
    trial,
    mean_treatment,
    var_treatment_2019_m,
    var_treatment_2020_m,
    var_treatment_2021_m,
    var_treatment_2022_m,
    var_treatment_2023_m,
    var_treatment
  )

# merge with precipitation (monsoon and total)
year_pp <- met_00_23_50 %>%
  filter(Year > 2018) %>% 
  group_by(Year) %>% 
  summarise(sum_pp = sum(Precipitation))

year_mons_pp <- met_00_23_50 %>%
  filter(Month > 5 & Month < 10 & Year > 2018) %>% 
  group_by(Year) %>% 
  summarise(sum_mons_pp = sum(Precipitation))

# collapse Mean-Var variable (make loop or fxn)
blue_yr_trt <- blue_yr_trt %>% 
  mutate(
    mv19 =
      case_when(
        mean_treatment == "ambient" & var_treatment_2019_m == "ambient" ~ 0
        , mean_treatment == "reduced" & var_treatment_2019_m == "ambient" ~ -25
        , mean_treatment == "ambient" & var_treatment_2019_m == "increase" ~ 50
        , mean_treatment == "reduced" & var_treatment_2019_m == "increase" ~ 25
        , mean_treatment == "ambient" & var_treatment_2019_m == "decrease" ~ -50
        , plot == 4|7|17|23|26 ~ -75
       # for some reason the same conditional doesn't work, soft coded for progress but would love to figure out why it doesn't work, see below
      )
  )
#which(blue_yr_trt$mean_treatment == "reduced" & blue_yr_trt$var_treatment_2019_m == "decrease")
#blue_yr_trt[which(blue_yr_trt$plot == 7), c("mean_treatment","var_treatment_2019")]

#unique(blue_yr_trt[which(is.na(blue_yr_trt$mv19)),2])
#unique(blue_yr_trt$mv19)

# view(trts[,c("plot","mean_treatment","var_treatment_2020")])
blue_yr_trt <- blue_yr_trt %>% 
  mutate(
    mv20 =
      case_when(
        mean_treatment == "ambient" & var_treatment_2020_m == "ambient" ~ 0
        , mean_treatment == "reduced" & var_treatment_2020_m == "ambient" ~ -25
        , mean_treatment == "ambient" & var_treatment_2020_m == "increase" ~ 50
        , mean_treatment == "reduced" & var_treatment_2020_m == "increase" ~ 25
        , mean_treatment == "ambient" & var_treatment_2020_m == "decrease" ~ -50
        , plot == 4|7|17|23|26 ~ -75 # for some reason the same conditional doesn't work, soft coded for progress but would love to figure out why it doesn't work
      )
  )
unique(blue_yr_trt$mv20)

# view(trts[,c("plot","mean_treatment","var_treatment_2021")])
blue_yr_trt <- blue_yr_trt %>% 
  mutate(
    mv21 =
      case_when(
        mean_treatment == "ambient" & var_treatment_2021_m == "ambient" ~ 0
        , mean_treatment == "reduced" & var_treatment_2021_m == "ambient" ~ -25
        , mean_treatment == "ambient" & var_treatment_2021_m == "increase" ~ 50
        , mean_treatment == "reduced" & var_treatment_2021_m == "increase" ~ 25
        , mean_treatment == "ambient" & var_treatment_2021_m == "decrease" ~ -50
        , plot == 4|8|18|24|26 ~ -75 # for some reason the same conditional doesn't work, soft coded for progress but would love to figure out why it doesn't work
      )
  )
unique(blue_yr_trt$mv21)

# view(trts[,c("plot","mean_treatment","var_treatment_2022")])
blue_yr_trt <- blue_yr_trt %>% 
  mutate(
    mv22 =
      case_when(
        mean_treatment == "ambient" & var_treatment_2022_m == "ambient" ~ 0
        , mean_treatment == "reduced" & var_treatment_2022_m == "ambient" ~ -25
        , mean_treatment == "ambient" & var_treatment_2022_m == "increase" ~ 50
        , mean_treatment == "reduced" & var_treatment_2022_m == "increase" ~ 25
        , mean_treatment == "ambient" & var_treatment_2022_m == "decrease" ~ -50
        , plot == 4|7|18|24|25 ~ -75 # for some reason the same conditional doesn't work, soft coded for progress but would love to figure out why it doesn't work
      )
  )
unique(blue_yr_trt$mv22)

blue_yr_trt <- blue_yr_trt %>% 
  mutate(
    mv23 =
      case_when(
        mean_treatment == "ambient" & var_treatment_2023_m == "ambient" ~ 0
        , mean_treatment == "reduced" & var_treatment_2023_m == "ambient" ~ -25
        , mean_treatment == "ambient" & var_treatment_2023_m == "increase" ~ 50
        , mean_treatment == "reduced" & var_treatment_2023_m == "increase" ~ 25
        , mean_treatment == "ambient" & var_treatment_2023_m == "decrease" ~ -50
        , plot == 4|8|18|24|26 ~ -75 # for some reason the same conditional doesn't work, soft coded for progress but would love to figure out why it doesn't work
      )
  )
unique(blue_yr_trt$mv23)

# bring in total precip, mons_precip, and create proportional rain for monsoon and total based on treatment
blue_yr_trt <- left_join(blue_yr_trt, year_pp, by = c("Obs_Year"="Year"))
blue_yr_trt <- left_join(blue_yr_trt, year_mons_pp, by = c("Obs_Year"="Year"))

## could put proportional precip here

# remove NE and 2019
blue_yr_trt <- 
  blue_yr_trt %>%  
  filter(!(Add_Year == 2019 & Corner == "NE"))

# rescale Obs Year and precip
blue_yr_trt$Obs_Year_sc <- blue_yr_trt$Obs_Year - 2018
blue_yr_trt$sum_pp_sc <- blue_yr_trt$sum_pp - 200
blue_yr_trt$sum_mons_pp_sc <- blue_yr_trt$sum_mons_pp - 80

```

Try creating a few different scaled or combined variables for modeling. Try simplifying random effect structure (limit to 1\|Quad_ID and/or 1\|Obs_Year) Try combining mean and variance treatment into one.

```{r}
blue_yr_trt$Obs_Year_sc_2 <- blue_yr_trt$Obs_Year - mean(blue_yr_trt$Obs_Year)
blue_yr_trt$sum_pp_sc_2 <- blue_yr_trt$sum_pp - mean(blue_yr_trt$sum_pp)
blue_yr_trt$sum_mons_pp_sc_2 <- blue_yr_trt$sum_mons_pp - mean(blue_yr_trt$sum_mons_pp)

blue_yr_trt$Quad_ID <- paste0(blue_yr_trt$Add_Year,blue_yr_trt$plot,blue_yr_trt$Species,blue_yr_trt$Corner)

blue_yr_trt$Quad_ID_ne_yr <- paste0(blue_yr_trt$plot,blue_yr_trt$Species,blue_yr_trt$Corner)

blue_yr_trt$meanvar <- paste0(blue_yr_trt$mean_treatment,blue_yr_trt$var_treatment)
```

Try new models. Try a different optimizer -- didn't work. Try a fixed effects model only -- convergence failure went away. Check for overdispersion

Question: How does a changing climate mean and variance affect co-domininant grass germination?

```{r}
#| warning: false
# Try both species together first
m0 <- glm(Germ.binom ~ 1, family = binomial, data = blue_yr_trt)
m1 <- glmer(Germ.binom ~ 1 + (1|Obs_Year_sc), family = binomial, data = blue_yr_trt)
m2 <- glmer(Germ.binom ~ 1 + (1|block), family = binomial, data = blue_yr_trt)
m3 <- glmer(Germ.binom ~ 1 + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt)

mall <- glmer(Germ.binom ~ Species*mean_treatment*var_treatment*sum_pp_sc + (1|block), family = binomial, data = blue_yr_trt)

mall2 <- glmer(Germ.binom ~ Species*mean_treatment*var_treatment + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt)

mall3 <- glmer(Germ.binom ~ Species*mean_treatment*var_treatment + (1|sum_pp_sc) + (1|block), family = binomial, data = blue_yr_trt)

mall5 <- glmer(Germ.binom ~ mean_treatment*var_treatment*sum_pp_sc + (1|block), family = binomial, data = blue_yr_trt)

m_pp <- glmer(Germ.binom ~ sum_pp_sc + (1|block), family = binomial, data = blue_yr_trt)

mall6 <- glmer(Germ.binom ~ mean_treatment*sum_pp_sc + (1|block), family = binomial, data = blue_yr_trt)

mall7 <- glmer(Germ.binom ~ var_treatment*sum_pp_sc + (1|block), family = binomial, data = blue_yr_trt)

mall8 <- glmer(Germ.binom ~ var_treatment*mean_treatment + (1|sum_pp_sc) + (1|block), family = binomial, data = blue_yr_trt)

mall9 <- glmer(Germ.binom ~ var_treatment*mean_treatment + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt)

ICtab(m0,m1,m2,m3,mall,mall2,mall3, mall5, m_pp, mall6, mall7, mall8, mall9)
# mall8 or 9 are best
summary(mall8)
#mall

# lrtest(m_mons_max, m3)

# Check for overdispersion
# deviance/residual df
19536.0/44443 

```

Best model is one with an interactive effect of mean and variance treatment with block and year (either precip or year) as random effects.

```{r}
Anova(mall8)
Anova(mall9)

summary(mall8)
summary(mall9)

mall9a <- glmer(Germ.binom ~ var_treatment*mean_treatment + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt)

mall9b <- glmer(Germ.binom ~ 0 + var_treatment:mean_treatment + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt)
summary(mall9b)

# this does give predicted probabilities for each group (ignoring random effects) because predictors are categorical
plogis(fixef(mall9b))
# highest germination (6%) is in ambient conditions
Anova(mall9)

library(emmeans)
emmeans(mall9, ~ var_treatment:mean_treatment)
# Can I just transform these and use them for graphing
```

## Graph germination by year and treatments

Graph it so two panels are the two mean treatments and -axis are variance treatments bar graphs of estimated proportion of germination by species and year.

Use original data (no observation year cohorts, Year Added only). Prep data below.

```{r}
#| warning: false
#| message: false

blue_19_23_trt_NE19rm$p_hat <- blue_19_23_trt_NE19rm$Germ.binom/1

germ_summary <- blue_19_23_trt_NE19rm %>% 
  group_by(Add_Year, mean_treatment, var_treatment, Species) %>% summarize(avg_germ = mean(p_hat))

germ_summary_all <- blue_19_23_trt_NE19rm %>% 
  group_by(mean_treatment, var_treatment, Species) %>% summarize(avg_germ = mean(p_hat))

```

Plot all years together.

```{r}
germ_all <- ggplot(germ_summary_all, aes(x=var_treatment, y = avg_germ, group = Species, fill = Species, na.rm = TRUE)) + scale_fill_manual(values=c("black","cornflowerblue")) + geom_col(position = position_dodge()) + facet_grid(. ~ mean_treatment) + labs(x = "Variance Treatment", y = "Estimated Germination Probability") + theme_bw()

ggsave("Germ_All.jpg", germ_all, width = 7, height = 7)
```

Species functionally the same for all treatments, no major differences between treatments but lowest germination in reduced mean and ambient variance treatment.

Break out each year.

```{r}
germ_yr <- ggplot(germ_summary, aes(x=var_treatment, y = avg_germ, group = Species, fill = Species, na.rm = TRUE)) + scale_fill_manual(values=c("black","cornflowerblue")) + geom_col(position = position_dodge()) + facet_grid(Add_Year ~ mean_treatment) + labs(title = "Germination of blue and black grama by Year Added Cohort", x = "Variance Treatment", y = "Estimated Germination Probability") + theme_bw()
germ_yr

ggsave("GermxAdd_Year.jpg", germ_yr, width = 7, height = 12)
```

High interannual variation in germination between species and treatments, dependent on rainfall.

Try it using Observation Year cohorts.

```{r}
#| warning: false
#| message: false

blue_yr_trt$p_hat <- blue_yr_trt$Germ.binom/1

# This is the last version of blue_yr_trt
# Save is as csv and use above
write_csv(blue_yr_trt, "blue_yr_trt.csv")

blue_19_23_trt_NE19rm$p_hat <- blue_19_23_trt_NE19rm$Germ.binom/1

germ_summary <- blue_yr_trt %>% 
  group_by(Obs_Year, mean_treatment, var_treatment, Species) %>% summarize(avg_germ = mean(p_hat))

germ_summary_all <- blue_19_23_trt_NE19rm %>% 
  group_by(mean_treatment, var_treatment, Species) %>% summarize(avg_germ = mean(p_hat))

```

Graph by Obs year.

```{r}
germ_yr <- ggplot(germ_summary, aes(x=var_treatment, y = avg_germ, group = Species, fill = Species, na.rm = TRUE)) + scale_fill_manual(values=c("black","cornflowerblue")) + geom_col(position = position_dodge()) + facet_grid(Obs_Year ~ mean_treatment) + labs(x = "Variance Treatment", y = "Estimated Germination Probability") + theme_bw()
germ_yr

ggsave("GermxObs_Year.jpg", germ_yr, width = 7, height = 12)
```

## Soil Moisture Model & Graph Germination Events

```{r}
# Merge germination data from major soil moisture events with soil moisture data from major events, join by Obs_Date and Plot
# str(sm_event_vars)
# str(germ_sm)

germ_sm_df <- left_join(sm_event_vars, germ_sm, by = join_by(Plot == Plot, Obs_Date == Obs_Date))

germ_sm_df$Obs_Year_sc <- germ_sm_df$Obs_Year - 2018
summary(germ_sm_df)

germ_sm_df_narm <- germ_sm_df[which(complete.cases(germ_sm_df) == TRUE),]

# bring in block
germ_sm_df_narm <- left_join(germ_sm_df_narm, trts, by=join_by(Plot))

# str(germ_sm_df_narm)

germ_sm_df_narm <- germ_sm_df_narm %>% 
  mutate(avg_7_max_per = avg_7_max*100,
         avg_7_per = avg_7*100,
         avg_mons_max_per = avg_mons_max*100,
         mons_max_per = mons_max*100)
```

Find the best model for germination probability with soil moisture.

```{r}
m0 <- glm(Germ.binom ~ 1, family = binomial, data = germ_sm_df_narm)
m1 <- glmer(Germ.binom ~ 1 + (1|Obs_Year_sc), family = binomial, data = germ_sm_df_narm)
m2 <- glmer(Germ.binom ~ 1 + (1|block), family = binomial, data = germ_sm_df_narm)
m3 <- glmer(Germ.binom ~ 1 + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_max_7 <- glmer(Germ.binom ~ avg_7_max_per + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_sp <- glmer(Germ.binom ~ Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_avg_7 <- glmer(Germ.binom ~ avg_7_per + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_mons_avg <- glmer(Germ.binom ~ avg_mons_max_per + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_mons_max <- glmer(Germ.binom ~ mons_max_per + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

ICtab(m0,m1,m2,m3,m_max_7,m_sp,m_avg_7,m_mons_avg,m_mons_max)
lrtest(m_mons_max, m3)
Anova(m_mons_max)
summary(m_mons_max)
#mall

# Check for overdispersion
# deviance/residual df
10314.2/27751 
```

Model using the maximum soil moisture from monsoon event is best model so far. Now tinker with Species and random effects.

```{r}
m3 <- glmer(Germ.binom ~ 1 + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_mons_max <- glmer(Germ.binom ~ mons_max_per + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_mons_max_sp <- glmer(Germ.binom ~ mons_max_per + Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_mons_max_x_sp <- glmer(Germ.binom ~ mons_max_per*Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)


ICtab(m3,m_mons_max,m_mons_max_sp,m_mons_max_x_sp)
lrtest(m_mons_max_sp, m_mons_max_x_sp)
# no significant difference, go with the simpler model
Anova(m_mons_max_sp)
summary(m_mons_max_sp)

# When soil moisture is 0 and species is black, there's a 1.2% probability or baseline odds of germination
exp(-4.423053)

# For every 1 percent increase in monsoon maximum soil moisutre, germination odds increases by 8%
exp(0.080366)

# Odds of germination if you're species blue is 81.3% of being black
exp(-0.206997)

# Check for overdispersion
# deviance/residual df
# 10314.2/27751 

m_mons_max_sp <- glmer(Germ.binom ~ mons_max_per + Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

m_mons_max_sp_b <- glmer(Germ.binom ~ 0 + mons_max_per + Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = germ_sm_df_narm)

summary(m_mons_max_sp_b)

# monsoon maximum soil moisture and species identity affects germination
Anova(m_mons_max_sp)

# soil moisture has a positive effect on germination. If you're blue grama, it's a negative effect
fixef(m_mons_max_sp)

# germination differs more among years than among blocks (varies more temporally than spatially)
VarCorr(m_mons_max_sp)

# Can't use the below code for predicted probabilities because predictor is continuous. You'll have to create a predicted response curve
# plogis(fixef(m_mons_max_sp_b))

fe <- fixef(m_mons_max_sp_b)

# For Species BLACK at mean soil moisture (e.g., 0.5)
logit_p_black <- fe["mons_max_per"] * 0.2 + fe["SpeciesBLACK"]
p_black <- plogis(logit_p_black)

# For Species BLUE at same moisture
logit_p_blue <- fe["mons_max_per"] * 0.2 + fe["SpeciesBLUE"]
p_blue <- plogis(logit_p_blue)

# This gives you the actual predicted germination probabilities for each species at soil moisture = 0.2.
# You can then repeat this over a range of moisture values to plot response curves.
p_black
p_blue
```

Chose the additive model because it's simpler.

Graph raw values below.


```{r}
germ_sm_df_narm$trial <- 1

germ_summary_sm <- germ_sm_df_narm %>% 
  group_by(Plot, Obs_Date, Species) %>% 
  mutate(germ_prop = sum(Germ.binom)/sum(trial)) %>% 
  select(Plot,
         Obs_Date,
         Species,
         mons_max,
         germ_prop) %>% 
  distinct()
```

```{r}
#| message: false

germ_sm_plot <- ggplot(data = germ_summary_sm, aes(x = mons_max, y = germ_prop, color = Species)) + # assign data to x- and y-axes
  geom_point(alpha = 0.5) +    # plot it with a scatterplot, pick color of the points
  geom_smooth(method = 'lm', fill = NA, linewidth = 0.75) +
  labs(x = "Soil Moisture Maximum (VWC)",    # x-axis label
       y = "Germination Proportion") + 
  scale_color_manual(values=c("black","cornflowerblue")) + 
  theme_bw()
germ_sm_plot

ggsave("germ_sm_plot.jpg",germ_sm_plot)
```

Next try to graph with actual predicted values or coefficients

We could also look at paired proportion data for same events and categorize how many times Black won versus blue

Is temperature the deciding factor? Because we could hypothesize that warmer temps could swing the favor to black grama

## Survival Model & Graph

Now we want to analyze survival of seedlings. I used this link as a template: https://www.emilyzabor.com/survival-analysis-in-r.html.

Independent variables of interest: Species, Add_year, mean_treatment, var_treatment

```{r}
# Reminder: Survival dataset is all toothpick IDs that germinated, the date they germinated, the date they were last observed + 7 days (assuming they died) 
head(surv)
# str(surv)
summary(surv)
# Plants that are two years old, I'm not confident they died or just stopped being monitored

# Sample of the survival time in days, "+" denotes still alive at time of observation
# Surv(surv$Surv_days, surv$Status)[1:1000]

# survfit() creates survival curves using the Kaplan_Meier method based on a formula
# overall survival curve
s1 <- survfit(Surv(Surv_days, Status) ~ 1, data = surv)
# str(s1)

# survfit2 and ggsurvfit creates graphs
# Overall survival with confidence intervals
survfit2(Surv(Surv_days, Status) ~ 1, data = surv) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  ) + 
  add_confidence_interval() +
  add_risktable() 
# risk table shows those living who are at risk of dying and death events
# that have occured at 250 day intervals
# Highest die off happens before 250 days

# survival by species
survfit2(Surv(Surv_days, Status) ~ Species, data = surv) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  ) + 
  add_confidence_interval() +
  add_risktable()

# probability of surviving a year 
summary(survfit(Surv(Surv_days, Status) ~ 1, data = surv), times = 365.25)
summary(survfit(Surv(Surv_days, Status) ~ Species, data = surv), times = 365.25) # don't understand why it's 365.25
# probability of surviving a year if black grama is 18.7%
# probability of surviving a year if blue grama is 20.1%
# overall is 19.5%

# quantifies average survival time using median
survfit(Surv(Surv_days, Status) ~ 1, data = surv)
# median survival time is 50 days
survfit(Surv(Surv_days, Status) ~ Species, data = surv)
# median survival time for black is 51 days,
# for blue it's 50 days
# these correspond to a survival probability of 50%

survdiff(Surv(Surv_days, Status) ~ Species, data = surv)
# difference in survival between species not significant (p = 0.8)

# Fits a regression model for survival
coxph(Surv(Surv_days, Status) ~ Species, data = surv)
```

We find that bue grama has slightly higher probability of survival after one year at 20.1% while black grama's probability of survival after 1 year is 18.7%.

Median survival time is 51 days for Black grama and 50 days for Blue, this corresponds to a survival probability of 50%.

There is no significant difference in overall survival according to species with a p-value of 0.8.

Try doing it by treatment or Add_Year or Death_Year. Need to add treatment back in

```{r}
survfit2(Surv(Surv_days, Status) ~ Add_Year, data = surv) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  ) + 
  add_confidence_interval()

summary(survfit(Surv(Surv_days, Status) ~ Add_Year, data = surv), times = 365.25)
# highest survival if planted in 2022, lowest in 2019

survfit(Surv(Surv_days, Status) ~ Add_Year, data = surv)
# highest median survival in 2023, lowest in 2019

survdiff(Surv(Surv_days, Status) ~ Add_Year, data = surv)
# significant difference among years


coxph(Surv(Surv_days, Status) ~ Add_Year, data = surv) 
```

Significant differences in survival among Add_Year.

Try treatments and then combos.

```{r}
#head(surv)
#head(trts)
trts$Plot <- trts$plot

surv_trt <- left_join(surv,trts,by=join_by(Plot))

survfit2(Surv(Surv_days, Status) ~ mean_treatment, data = surv_trt) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  ) + 
  add_confidence_interval()

summary(survfit(Surv(Surv_days, Status) ~ mean_treatment, data = surv_trt), times = 365.25)

survfit(Surv(Surv_days, Status) ~ mean_treatment, data = surv_trt)

survdiff(Surv(Surv_days, Status) ~ mean_treatment, data = surv_trt)
# no significant difference in mean treatments

coxph(Surv(Surv_days, Status) ~ mean_treatment, data = surv_trt)

survfit2(Surv(Surv_days, Status) ~ var_treatment, data = surv_trt) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  ) + 
  add_confidence_interval()

summary(survfit(Surv(Surv_days, Status) ~ var_treatment, data = surv_trt), times = 365.25)

survfit(Surv(Surv_days, Status) ~ var_treatment, data = surv_trt)
# much higher median survival if in a variance increase plot (59 vs 38 for ambient)

survdiff(Surv(Surv_days, Status) ~ var_treatment, data = surv_trt)
# significant difference in survival between variance treatments

coxph(Surv(Surv_days, Status) ~ var_treatment, data = surv_trt)

```

Var treatment is significant, mean is not.

```{r}
# Cox model with all explanatory variables
cox_model <- coxph(Surv(Surv_days, Status) ~ Species + mean_treatment + var_treatment + Add_Year, data = surv_trt)
summary(cox_model)


# Kaplan-Meier for categorical explanatory variable
km_model <- survfit(Surv(Surv_days, Status) ~ Species, data = surv_trt)
ggsurvplot(km_model, data = surv_trt)

# Test proportional hazards assumption
cox.zph(cox_model)

# Drop Add_Year because it violates assumptions

cox_model <- coxph(Surv(Surv_days, Status) ~ Species + mean_treatment + var_treatment, data = surv_trt)
summary(cox_model)


step_model <- step(cox_model)
summary(step_model)

# Cox model with interaction between var1 and var2
cox_model <- coxph(Surv(Surv_days, Status) ~ var_treatment * mean_treatment, data = surv_trt)

# Model summary
summary(cox_model)

# Stepwise selection
step_model <- step(cox_model)
summary(step_model)

```

Overall best model seems to be the one with var_treatment\*mean_treatment.

Try graphing using predicitve values and then by faceting with two facets of mean and each line is variance.

```{r}
# str(surv_trt)
# Create new data for predicting survival curves with the interaction between var1 and var2
new_data <- expand.grid(
  var_treatment = levels(as.factor(surv_trt$var_treatment)),  # Levels of the first categorical variable
  mean_treatment = levels(as.factor(surv_trt$mean_treatment))   # Levels of the second categorical variable
)

# Compute the predicted survival curves for each combination of var1 and var2
predicted_surv <- survfit(cox_model, newdata = new_data)

# Plot the survival curves
ggsurvplot(predicted_surv, data = new_data,
           pval = TRUE,                    # Add p-value for the log-rank test
           legend.title = "Combination of var1 and var2",
           palette = "Set1",               # Custom color palette
           xlab = "Time", ylab = "Survival Probability", 
           title = "Survival Curves by Interaction of var1 and var2")

surv_trt$mean_var <- paste(surv_trt$mean_treatment,surv_trt$var_treatment,sep = "_")

survfit2(Surv(Surv_days, Status) ~ mean_var, data = surv_trt) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  ) + 
  add_confidence_interval()

# LEFT OFF HERE #
```

Graph shows lowest survival in ambient ambient plots -- interesting. Once again species doesn't matter

## Legacy Model & Graph

My hypothesis is that plots that experience drought conditions the year prior and the experience high precip, have higher germination due to reduced competition.

A couple options:
1. Change in calculated plot rainfall. Use the treatment spreadsheet to attach percentages for each plot in each year. Then multiply the percentage by that years rainfall or monsoon rainfall. Quantify the change in rainfall from year-1 to year and use that to model germination. It's a little brief, legacy should really be longer. 
2. Use actual spring cover data to show that pre-existing cover conditions or decline in cover and drought relief provide conditions for germination. 
3. Cover + calculated rainfall, the lower the cover and higher the rainfall the better the germination - 

Variables: Change in rainfall year - year -1 (ex: 2020-2019) 
Whiplash Y/N 
April cover 
Current rainfall 
Species 
Change in prior year cover year April cover - year -1 April cover

Create variables

Mean-Variance Cover and Height: https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-sev.349.1

Mean_Variance Biomass: https://portal.edirepository.org/nis/mapbrowse?packageid=knb-lter-sev.350.1

```{r}
#| echo: false
#head(met_00_23_50)
#head(trts)
#head(bluebyyear) # has year and year + 1 germination data
#head(blue_yr_trt) # current year and past year germ + treatments and precip

## Change in rainfall year - year -1 (ex: 2020-2019)
# Use blue_yr_trt to calculate year - year -1 rainfall
# subset blue_yr_trt for rainfall
blue_pp_dif <- blue_yr_trt %>% 
  select(
    plot,
    Obs_Year,
    sum_pp,
    sum_mons_pp,
    mv19,
    mv20,
    mv21,
    mv22,
    mv23
  )

# create a compatible dataframe for 2018, which includes all thirty plots
met_sum_18<- met_00_23_50 %>%
  filter(Year == 2018) %>% 
  summarise(
    sum_pp = sum(Precipitation, na.rm = TRUE)) %>% 
  distinct()

met_mons_18 <- met_00_23_50 %>%
  filter(Month > 5 & Month < 10 & Year == 2018) %>% 
  summarise(
    sum_mons_pp = sum(Precipitation))


pp_18 <- data.frame(plot = 1:30
           ,Obs_Year = 2018
           , sum_pp = met_sum_18
           , sum_mons_pp = met_mons_18
           , mv19 = 0
           , mv20 = 0
           , mv21 = 0
           , mv22 = 0
           , mv23 = 0
           )

blue_pp_difs <- rbind(pp_18, blue_pp_dif)

# Go back and update mve treatment with 2023
# str(blue_pp_difs)
blue_pp_difs$mvfactor18 <- 1

blue_pp_difs <-
  blue_pp_difs %>%
  mutate(
    mvfactor19 =
      case_when(
        mv19 == -75 ~ 0.25
        , mv19 == -50 ~ 0.5
        , mv19 == -25 ~ 0.75
        , mv19 == 0 ~ 1
        , mv19 == 25 ~ 1.25
        , mv19 == 50 ~ 1.5
      )
  )

blue_pp_difs <-
  blue_pp_difs %>%
  mutate(
    mvfactor20 =
      case_when(
        mv20 == -75 ~ 0.25
        , mv20 == -50 ~ 0.5
        , mv20 == -25 ~ 0.75
        , mv20 == 0 ~ 1
        , mv20 == 25 ~ 1.25
        , mv20 == 50 ~ 1.5
      )
  )

blue_pp_difs <-
  blue_pp_difs %>%
  mutate(
    mvfactor21 =
      case_when(
        mv21 == -75 ~ 0.25
        , mv21 == -50 ~ 0.5
        , mv21 == -25 ~ 0.75
        , mv21 == 0 ~ 1
        , mv21 == 25 ~ 1.25
        , mv21 == 50 ~ 1.5
      )
  )

blue_pp_difs <-
  blue_pp_difs %>%
  mutate(
    mvfactor22 =
      case_when(
        mv22 == -75 ~ 0.25
        , mv22 == -50 ~ 0.5
        , mv22 == -25 ~ 0.75
        , mv22 == 0 ~ 1
        , mv22 == 25 ~ 1.25
        , mv22 == 50 ~ 1.5
      )
  )

blue_pp_difs <-
  blue_pp_difs %>%
  mutate(
    mvfactor23 =
      case_when(
        mv23 == -75 ~ 0.25
        , mv23 == -50 ~ 0.5
        , mv23 == -25 ~ 0.75
        , mv23 == 0 ~ 1
        , mv23 == 25 ~ 1.25
        , mv23 == 50 ~ 1.5
      )
  )

blue_pp_18 <- 
  blue_pp_difs %>% 
  select(
    plot,
    Obs_Year,
    sum_pp,
    sum_mons_pp,
    mvfactor18
  ) %>% 
  filter(
    Obs_Year == 2018
  ) %>% 
  mutate(
  prop_pp_18 = sum_pp*mvfactor18, #mvfactor is 1 for 2018
  prop_mons_pp_18 = sum_mons_pp*mvfactor18) %>% 
  select(
    plot,
    prop_pp_18,
    prop_mons_pp_18
  ) %>% 
  distinct()

blue_pp_19 <- 
  blue_pp_difs %>% 
  select(
    plot,
    Obs_Year,
    sum_pp,
    sum_mons_pp,
    mvfactor19
  ) %>% 
  filter(
    Obs_Year == 2019
  ) %>% 
  mutate(
  prop_pp_19 = sum_pp*mvfactor19,
  prop_mons_pp_19 = sum_mons_pp*mvfactor19) %>% 
  select(
    plot,
    prop_pp_19,
    prop_mons_pp_19
  ) %>% 
  distinct()

blue_pp_20 <- 
  blue_pp_difs %>% 
  select(
    plot,
    Obs_Year,
    sum_pp,
    sum_mons_pp,
    mvfactor20
  ) %>% 
  filter(
    Obs_Year == 2020
  ) %>% 
  mutate(
  prop_pp_20 = sum_pp*mvfactor20,
  prop_mons_pp_20 = sum_mons_pp*mvfactor20) %>% 
  select(
    plot,
    prop_pp_20,
    prop_mons_pp_20
  ) %>% 
  distinct()

blue_pp_21 <- 
  blue_pp_difs %>% 
  select(
    plot,
    Obs_Year,
    sum_pp,
    sum_mons_pp,
    mvfactor21
  ) %>% 
  filter(
    Obs_Year == 2021
  ) %>% 
  mutate(
  prop_pp_21 = sum_pp*mvfactor21,
  prop_mons_pp_21 = sum_mons_pp*mvfactor21) %>% 
  select(
    plot,
    prop_pp_21,
    prop_mons_pp_21
  ) %>% 
  distinct()

blue_pp_22 <- 
  blue_pp_difs %>% 
  select(
    plot,
    Obs_Year,
    sum_pp,
    sum_mons_pp,
    mvfactor22
  ) %>% 
  filter(
    Obs_Year == 2022
  ) %>% 
  mutate(
  prop_pp_22 = sum_pp*mvfactor22,
  prop_mons_pp_22 = sum_mons_pp*mvfactor22) %>% 
  select(
    plot,
    prop_pp_22,
    prop_mons_pp_22
  ) %>% 
  distinct()

blue_pp_23 <- 
  blue_pp_difs %>% 
  select(
    plot,
    Obs_Year,
    sum_pp,
    sum_mons_pp,
    mvfactor23
  ) %>% 
  filter(
    Obs_Year == 2023
  ) %>% 
  mutate(
  prop_pp_23 = sum_pp*mvfactor23,
  prop_mons_pp_23 = sum_mons_pp*mvfactor23) %>% 
  select(
    plot,
    prop_pp_23,
    prop_mons_pp_23
  ) %>% 
  distinct()

# merge by plot, make a wide frame for subtractions then subset and cast
blue_pp_0 <- full_join(blue_pp_18,blue_pp_19, by=join_by(plot))
blue_pp_1 <- full_join(blue_pp_0,blue_pp_20, by=join_by(plot))
blue_pp_2 <- full_join(blue_pp_1,blue_pp_21, by=join_by(plot))
blue_pp_3 <- full_join(blue_pp_2,blue_pp_22, by=join_by(plot))
blue_pp <- full_join(blue_pp_3,blue_pp_23, by=join_by(plot))

blue_pp <- blue_pp %>% 
  mutate(
      pp_19_18 = prop_pp_19-prop_pp_18
    , pp_20_19 = prop_pp_20-prop_pp_19
    , pp_21_20 = prop_pp_21-prop_pp_20
    , pp_22_21 = prop_pp_22-prop_pp_21
    , pp_23_22 = prop_pp_23-prop_pp_22
    , pp_mons_19_18 = prop_mons_pp_19-prop_mons_pp_18
    , pp_mons_20_19 = prop_mons_pp_20-prop_mons_pp_19
    , pp_mons_21_20 = prop_mons_pp_21-prop_mons_pp_20
    , pp_mons_22_21 = prop_mons_pp_22-prop_mons_pp_21
    , pp_mons_23_22 = prop_mons_pp_23-prop_mons_pp_22
  )
# str(blue_pp)

# separate mons dif and total pp dif into their own datasets and make longer and add years, then merge with master
blue_pp_total_difs <- blue_pp %>% 
  select(
    plot,
    pp_19_18,
    pp_20_19,
    pp_21_20,
    pp_22_21,
    pp_23_22
  ) %>% 
  pivot_longer(cols=c(
    pp_19_18,
    pp_20_19,
    pp_21_20,
    pp_22_21,
    pp_23_22),
    names_to = "year_dif",
    values_to = "pp_dif") %>% 
  mutate(
    Obs_Year = 
    case_when(
      year_dif == "pp_19_18" ~ 2019,
      year_dif == "pp_20_19" ~ 2020,
      year_dif == "pp_21_20" ~ 2021,
      year_dif == "pp_22_21" ~ 2022,
      year_dif == "pp_23_22" ~ 2023
    )
  ) %>% 
  mutate(
    whiplash_total = 
      case_when(
        pp_dif > 0 ~ "drier prior",
        pp_dif < 0 ~ "wetter prior"
      )
  ) %>% 
  select(-"year_dif")

blue_pp_mons_difs <- blue_pp %>% 
  select(
    plot,
    pp_mons_19_18,
    pp_mons_20_19,
    pp_mons_21_20,
    pp_mons_22_21,
    pp_mons_23_22
  ) %>% 
  pivot_longer(cols=c(
    pp_mons_19_18,
    pp_mons_20_19,
    pp_mons_21_20,
    pp_mons_22_21,
    pp_mons_23_22),
    names_to = "year_dif",
    values_to = "pp_mons_dif") %>% 
  mutate(
    Obs_Year = 
    case_when(
      year_dif == "pp_mons_19_18" ~ 2019,
      year_dif == "pp_mons_20_19" ~ 2020,
      year_dif == "pp_mons_21_20" ~ 2021,
      year_dif == "pp_mons_22_21" ~ 2022,
      year_dif == "pp_mons_23_22" ~ 2023
    )
  ) %>% 
  mutate(
    whiplash_mons = 
      case_when(
        pp_mons_dif > 0 ~ "drier prior",
        pp_mons_dif < 0 ~ "wetter prior"
      )
  ) %>% 
  select(-"year_dif")

# can do the same thing for proportional pp
blue_pp_totes <- blue_pp %>% 
  select(
    plot,
    prop_pp_19,
    prop_pp_20,
    prop_pp_21,
    prop_pp_22,
    prop_pp_23
  ) %>% 
  pivot_longer(cols=c(
    prop_pp_19,
    prop_pp_20,
    prop_pp_21,
    prop_pp_22,
    prop_pp_23),
    names_to = "year",
    values_to = "prop_pp") %>% 
  mutate(
    Obs_Year = 
    case_when(
      year == "prop_pp_19" ~ 2019,
      year == "prop_pp_20" ~ 2020,
      year == "prop_pp_21" ~ 2021,
      year == "prop_pp_22" ~ 2022,
      year == "prop_pp_23" ~ 2023
    )
  ) %>% 
  select(-"year")

blue_pp_mons_totes <- blue_pp %>% 
  select(
    plot,
    prop_mons_pp_19,
    prop_mons_pp_20,
    prop_mons_pp_21,
    prop_mons_pp_22,
    prop_mons_pp_23
  ) %>% 
  pivot_longer(cols=c(
    prop_mons_pp_19,
    prop_mons_pp_20,
    prop_mons_pp_21,
    prop_mons_pp_22,
    prop_mons_pp_23),
    names_to = "year",
    values_to = "prop_mons_pp") %>% 
  mutate(
    Obs_Year = 
    case_when(
      year == "prop_mons_pp_19" ~ 2019,
      year == "prop_mons_pp_20" ~ 2020,
      year == "prop_mons_pp_21" ~ 2021,
      year == "prop_mons_pp_22" ~ 2022,
      year == "prop_mons_pp_23" ~ 2023
    )
  ) %>% 
  select(-"year")

# pivot_longer and then assign Obs_Year and join with blue_yr_trt
pp_difs <- left_join(blue_pp_total_difs, blue_pp_mons_difs, by = c("plot","Obs_Year"))

pp_1 <- left_join(pp_difs, blue_pp_totes, by = c("plot","Obs_Year"))
pp_2 <- left_join(pp_1, blue_pp_mons_totes, by = c("plot","Obs_Year"))

blue_yr_trt_ppdifs <- left_join(blue_yr_trt, pp_2, by = c("plot","Obs_Year"))
#str(blue_yr_trt)
#str(pp_difs)
#unique(pp_difs$plot)
```

```{r}
# maybe sneak peak at a graph?
germ_sum <- blue_yr_trt_ppdifs %>% 
  group_by(plot, Obs_Date, Species) %>% 
  mutate(germ_prop = sum(Germ.binom)/sum(trial)) %>% 
  select(plot,
         Obs_Date,
         Species,
         pp_mons_dif,
         germ_prop) %>% 
  distinct()

germ_leg_plot <- ggplot(data = germ_sum, aes(x = pp_mons_dif, y = germ_prop, color = Species)) + # assign data to x- and y-axes
  geom_point(alpha = 0.5) +    # plot it with a scatterplot, pick color of the points
  geom_smooth(method = 'lm', fill = NA, linewidth = 0.75) +
  labs(x = "Interannual difference in monsoon precipitation",    # x-axis label
       y = "Germination Proportion") + 
  scale_color_manual(values=c("black","cornflowerblue")) + 
  theme_bw()
germ_leg_plot

# maybe sneak peak at a graph?
germ_sum <- blue_yr_trt_ppdifs %>% 
  group_by(plot, Obs_Date, Species) %>% 
  mutate(germ_prop = sum(Germ.binom)/sum(trial)) %>% 
  select(plot,
         Obs_Date,
         Species,
         pp_dif,
         germ_prop) %>% 
  distinct()

germ_leg_plot <- ggplot(data = germ_sum, aes(x = pp_dif, y = germ_prop, color = Species)) + # assign data to x- and y-axes
  geom_point(alpha = 0.5) +    # plot it with a scatterplot, pick color of the points
  geom_smooth(method = 'lm', fill = NA, linewidth = 0.75) +
  labs(x = "Interannual difference in total annual precipitation",    # x-axis label
       y = "Germination Proportion") + 
  scale_color_manual(values=c("black","cornflowerblue")) + 
  theme_bw()
germ_leg_plot

# Germination increases if the prior year was drier than the current year


germ_sum <- blue_yr_trt_ppdifs %>% 
  group_by(plot, Obs_Year, Species) %>% 
  mutate(germ_prop = sum(Germ.binom)/sum(trial)) %>% 
  select(plot,
         Obs_Year,
         Species,
         whiplash_mons,
         germ_prop) %>% 
  distinct()

ggplot(germ_sum, aes(x=whiplash_mons, y = germ_prop, group = Species, fill = Species, na.rm = TRUE)) + scale_fill_manual(values=c("black","cornflowerblue")) + geom_col(position = position_dodge()) +
labs(x = "Whiplash", y = "Estimated Germination Probability") + theme_bw()
# For some reason wetter prior has germination than drier. A lot of values that fall under wetter prior are super small, like a 6 mm difference in monsoon precip

germ_sum <- blue_yr_trt_ppdifs %>% 
  group_by(plot, Obs_Year, Species) %>% 
  mutate(germ_prop = sum(Germ.binom)/sum(trial)) %>% 
  select(plot,
         Obs_Year,
         Species,
         whiplash_total,
         germ_prop) %>% 
  distinct()

ggplot(germ_sum, aes(x=whiplash_total, y = germ_prop, group = Species, fill = Species, na.rm = TRUE)) + scale_fill_manual(values=c("black","cornflowerblue")) + geom_col(position = position_dodge()) +
labs(x = "Whiplash", y = "Estimated Germination Probability") + theme_bw()
# For some reason wetter prior has germination than drier 
```

```{r}
#| warning: false
#| message: false

# April (September?) cover and/or biomass
cover <- read.csv("sev349_mean_variance_quad_cover_height.csv")
biomass <- read.csv("sevnnn_mean_variance_biomass.csv")

cover_sum_Apr <- cover %>% 
  filter(
    site == "meanvar_blue" & season == 2
  ) %>% group_by(plot, quad, year, season, collection_date) %>% 
  summarise(cover_total = sum(cover)) %>% 
  group_by(plot, year, season, collection_date) %>% # values across quads look pretty similar most of the time, average across quads
  summarise(cover_avg = mean(cover_total)) %>% 
  mutate(
    Obs_Year = year,
    cover_Apr = cover_avg
  )

cover_sum_Sep <- cover %>% 
  filter(
    site == "meanvar_blue" & season == 3
  ) %>% group_by(plot, quad, year, season, collection_date) %>% 
  summarise(cover_total = sum(cover)) %>% 
  group_by(plot, year, season, collection_date) %>% # values across quads look pretty similar most of the time, average across quads
  summarise(cover_avg = mean(cover_total)) %>% 
  mutate(
    Obs_Year = year + 1,
    cover_Sep_prior = cover_avg
  )

# Either low cover in April, low cover September prior
# merge with blue yr trt
blue_yr_trt_pp_cover_1 <- left_join(blue_yr_trt_ppdifs, cover_sum_Apr, by = c("plot","Obs_Year"))

blue_yr_trt_pp_cover <- left_join(blue_yr_trt_pp_cover_1, cover_sum_Sep, by = c("plot","Obs_Year"))


# need to make a august version and do it for biomass and see what is the best predictor
# I think the treatment years are off because this doesn't make sense

# maybe sneak peak at a graph?
germ_sum <- blue_yr_trt_pp_cover %>%
  filter(season.x == 2) %>% 
  group_by(plot, Obs_Date, Species) %>% 
  mutate(germ_prop = sum(Germ.binom)/sum(trial)) %>% 
  select(plot,
         Obs_Date,
         Species,
         cover_Apr,
         germ_prop) %>% 
  distinct()

germ_cov_plot <- ggplot(data = germ_sum, aes(x = cover_Apr, y = germ_prop, color = Species)) + # assign data to x- and y-axes
  geom_point(alpha = 0.5) +    # plot it with a scatterplot, pick color of the points
  geom_smooth(method = 'lm', fill = NA, linewidth = 0.75) +
  labs(x = "Veg Cover (April)",    # x-axis label
       y = "Germination Proportion") + 
  scale_color_manual(values=c("black","cornflowerblue")) + 
  theme_bw()
germ_cov_plot
### Lower veg cover == higher germ

# maybe sneak peak at a graph?
germ_sum_S <- blue_yr_trt_pp_cover %>%
  filter(season.y == 3) %>%  
  group_by(plot, Obs_Date, Species) %>% 
  mutate(germ_prop = sum(Germ.binom)/sum(trial)) %>% 
  select(plot,
         Obs_Date,
         Species,
         cover_Sep_prior,
         germ_prop) %>% 
  distinct()

germ_cov_plot_S <- ggplot(data = germ_sum_S, aes(x = cover_Sep_prior, y = germ_prop, color = Species)) + # assign data to x- and y-axes
  geom_point(alpha = 0.5) +    # plot it with a scatterplot, pick color of the points
  geom_smooth(method = 'lm', fill = NA, linewidth = 0.75) +
  labs(x = "Veg Cover (September prior)",    # x-axis label
       y = "Germination Proportion") + 
  scale_color_manual(values=c("black","cornflowerblue")) + 
  theme_bw()
germ_cov_plot_S
### Higher veg in September year prior yields high germ next summer, inline with wetter prior monsoon years have higher germ
```

```{r}
## Try to find the best model to predict germination including Apr cover, September cover, proportional rainfall, total rainfall, species
str(blue_yr_trt_pp_cover)

## copy and pasted code from soil moisture section.

m0 <- glm(Germ.binom ~ 1, family = binomial, data = blue_yr_trt_pp_cover)
m1 <- glmer(Germ.binom ~ 1 + (1|Obs_Year_sc), family = binomial, data = blue_yr_trt_pp_cover)
m2 <- glmer(Germ.binom ~ 1 + (1|block), family = binomial, data = blue_yr_trt_pp_cover)
m3 <- glmer(Germ.binom ~ 1 + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_pp_dif <- glmer(Germ.binom ~ pp_dif + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_whip <- glmer(Germ.binom ~ whiplash_total + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_pp_mons_dif <- glmer(Germ.binom ~ pp_mons_dif + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_whip_mons <- glmer(Germ.binom ~ whiplash_mons + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_whip_mons_sp <- glmer(Germ.binom ~ whiplash_mons*Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_whip_mons_sp_2 <- glmer(Germ.binom ~ whiplash_mons + Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_prop_pp <- glmer(Germ.binom ~ prop_pp + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_prop_pp_sp <- glmer(Germ.binom ~ prop_pp*Species + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_prop_mons_pp <- glmer(Germ.binom ~ prop_mons_pp + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_Apr <- glmer(Germ.binom ~ cover_Apr + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

m_Sep <- glmer(Germ.binom ~ cover_Sep_prior + (1|block), family = binomial, data = blue_yr_trt_pp_cover)

ICtab(m0,m1,m2,m3,m_pp_dif,m_whip,m_pp_mons_dif,m_whip_mons,m_prop_pp,m_prop_mons_pp,m_Apr,m_Sep,m_whip_mons_sp, m_prop_pp_sp, m_whip_mons_sp_2)

# Best model appears to be interactive predictor variable of monsoon whiplash and species

m_whip_mons_sp_b <- glmer(Germ.binom ~ 0 + whiplash_mons:Species + (1|Obs_Year_sc) + (1|block), family = binomial, data = blue_yr_trt_pp_cover)


Anova(m_whip_mons_sp)
plogis(fixef(m_whip_mons_sp_b))
# So black grama is responding strongest to drier prior years
# why does the graph look different

lrtest(m_whip_mons_sp, m2)
summary(m_whip_mons_sp)

# Check for overdispersion
# deviance/residual df
deviance(m_whip_mons_sp)/44779
# <3 so we're good
```
